<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IvyHeterogeneousCore: std_ivy Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IvyHeterogeneousCore<span id="projectnumber">&#160;v0.1.0</span>
   </div>
   <div id="projectbrief">A modified C++ standard library for hybrid computing with GPUs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">std_ivy Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d0/dca/namespacestd__ivy_1_1__iterator__details" id="r_d0/dca/namespacestd__ivy_1_1__iterator__details"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dca/namespacestd__ivy_1_1__iterator__details.html">_iterator_details</a></td></tr>
<tr class="memdesc:d0/dca/namespacestd__ivy_1_1__iterator__details"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helpers for iterator trait detection. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dea/structstd__ivy_1_1add__parallel__op.html">add_parallel_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition policy for grouped parallel operations.  <a href="../../dc/dea/structstd__ivy_1_1add__parallel__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8b/classstd__ivy_1_1allocation__type__properties.html">allocation_type_properties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d43/classstd__ivy_1_1allocation__type__properties_3_01T_01const_01_4.html">allocation_type_properties&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3d/classstd__ivy_1_1allocator.html">allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/df9/structstd__ivy_1_1allocator__arg__t.html">allocator_arg_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d58/classstd__ivy_1_1allocator__primitive.html">allocator_primitive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d9a/classstd__ivy_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d00/structstd__ivy_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional-iterator category tag.  <a href="../../d0/d00/structstd__ivy_1_1bidirectional__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8b/structstd__ivy_1_1contiguous__iterator__tag.html">contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully contiguous iterator category tag.  <a href="../../d2/d8b/structstd__ivy_1_1contiguous__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d44/classstd__ivy_1_1deallocator__primitive.html">deallocator_primitive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d97/structstd__ivy_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward-iterator category tag.  <a href="../../d1/d97/structstd__ivy_1_1forward__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3f/structstd__ivy_1_1has__rebind.html">has_rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether a pointer-like type exposes a <code>rebind&lt;U&gt;</code> alias template.  <a href="../../d5/d3f/structstd__ivy_1_1has__rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dba/structstd__ivy_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input-iterator category tag.  <a href="../../df/dba/structstd__ivy_1_1input__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d07/structstd__ivy_1_1is__contiguous__iterator.html">is_contiguous_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait detecting whether a type is a contiguous iterator category.  <a href="../../dd/d07/structstd__ivy_1_1is__contiguous__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d81/structstd__ivy_1_1is__contiguous__iterator_3_01T_00_01std__ttraits_1_1enable__if__t_3_01__iterat010617f8fe9928c575c8bb18f27fb29b.html">is_contiguous_iterator&lt; T, std_ttraits::enable_if_t&lt; _iterator_details::has_iterator_category_v&lt; T &gt; &amp;&amp;std_ttraits::is_base_of_v&lt; contiguous_iterator_tag, typename T::iterator_category &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive contiguous-iterator trait specialization.  <a href="../../d4/d81/structstd__ivy_1_1is__contiguous__iterator_3_01T_00_01std__ttraits_1_1enable__if__t_3_01__iterat010617f8fe9928c575c8bb18f27fb29b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/structstd__ivy_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base iterator facade exposing canonical nested typedefs.  <a href="../../da/d54/structstd__ivy_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d13/structstd__ivy_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary iterator traits template extracting nested iterator typedefs.  <a href="../../db/d13/structstd__ivy_1_1iterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dfd/structstd__ivy_1_1iterator__traits_3_01T_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer specialization of iterator traits.  <a href="../../df/dfd/structstd__ivy_1_1iterator__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d24/classstd__ivy_1_1IvyBucketedIteratorBuilder.html">IvyBucketedIteratorBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/db9/classstd__ivy_1_1IvyContiguousIterator.html">IvyContiguousIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de3/classstd__ivy_1_1IvyContiguousIteratorBuilder.html">IvyContiguousIteratorBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc0/structstd__ivy_1_1IvyKeyEqualBinaryEval.html">IvyKeyEqualBinaryEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic key-equality evaluator parameterized by a binary predicate.  <a href="../../d9/dc0/structstd__ivy_1_1IvyKeyEqualBinaryEval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df3/structstd__ivy_1_1IvyKeyEqualBySqrtNCapacityEval.html">IvyKeyEqualBySqrtNCapacityEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-equality evaluator using modulo over sqrt(capacity)+1 bucketing strategy.  <a href="../../d8/df3/structstd__ivy_1_1IvyKeyEqualBySqrtNCapacityEval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d82/structstd__ivy_1_1IvyKeyEqualBySqrtNSizeEval.html">IvyKeyEqualBySqrtNSizeEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-equality evaluator using modulo over sqrt(size)+1 bucketing strategy.  <a href="../../d3/d82/structstd__ivy_1_1IvyKeyEqualBySqrtNSizeEval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d2d/classstd__ivy_1_1IvyOutputIterator.html">IvyOutputIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of the unified smart pointer template.  <a href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d3c/classstd__ivy_1_1IvyUnorderedMap.html">IvyUnorderedMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of <a class="el" href="../../d0/d3c/classstd__ivy_1_1IvyUnorderedMap.html" title="Forward declaration of IvyUnorderedMap.">IvyUnorderedMap</a>.  <a href="../../d0/d3c/classstd__ivy_1_1IvyUnorderedMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d97/classstd__ivy_1_1IvyVector.html">IvyVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of <a class="el" href="../../d2/d97/classstd__ivy_1_1IvyVector.html" title="Forward declaration of IvyVector.">IvyVector</a>.  <a href="../../d2/d97/classstd__ivy_1_1IvyVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd1/classstd__ivy_1_1kernel__generic__transfer__internal__memory.html">kernel_generic_transfer_internal_memory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc6/structstd__ivy_1_1kernel__op__parallel.html">kernel_op_parallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel wrapper that applies a reduction-like operation in grouped serial chunks.  <a href="../../dd/dc6/structstd__ivy_1_1kernel__op__parallel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d86/classstd__ivy_1_1memview.html">memview</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d63/structstd__ivy_1_1multiply__parallel__op.html">multiply_parallel_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication policy for grouped parallel operations.  <a href="../../d7/d63/structstd__ivy_1_1multiply__parallel__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d96/structstd__ivy_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output-iterator category tag.  <a href="../../d6/d96/structstd__ivy_1_1output__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/def/structstd__ivy_1_1parallel__op__base.html">parallel_op_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base policy for grouped parallel operations.  <a href="../../d3/def/structstd__ivy_1_1parallel__op__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dab/structstd__ivy_1_1partially__contiguous__iterator__tag.html">partially_contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially contiguous iterator category tag.  <a href="../../df/dab/structstd__ivy_1_1partially__contiguous__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d39/classstd__ivy_1_1pointer__traits.html">pointer_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General <a class="el" href="../../df/d39/classstd__ivy_1_1pointer__traits.html" title="General pointer_traits implementation for pointer-like classes.">pointer_traits</a> implementation for pointer-like classes.  <a href="../../df/d39/classstd__ivy_1_1pointer__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/classstd__ivy_1_1pointer__traits_3_01IvyUnifiedPtr_3_01T_00_01IPT_01_4_01_4.html">pointer_traits&lt; IvyUnifiedPtr&lt; T, IPT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/d39/classstd__ivy_1_1pointer__traits.html" title="General pointer_traits implementation for pointer-like classes.">pointer_traits</a> specialization for <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a>.  <a href="../../d2/db9/classstd__ivy_1_1pointer__traits_3_01IvyUnifiedPtr_3_01T_00_01IPT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classstd__ivy_1_1pointer__traits_3_01T_01_5_01_4.html">pointer_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw-pointer specialization of <a class="el" href="../../df/d39/classstd__ivy_1_1pointer__traits.html" title="General pointer_traits implementation for pointer-like classes.">pointer_traits</a>.  <a href="../../d0/d24/classstd__ivy_1_1pointer__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d90/structstd__ivy_1_1pointer__traits__rebind.html">pointer_traits_rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind resolver for pointer-like types that define <code>rebind&lt;U&gt;</code>.  <a href="../../d5/d90/structstd__ivy_1_1pointer__traits__rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d50/structstd__ivy_1_1pointer__traits__rebind_3_01S_3_01T_00_01Args_8_8_8_01_4_00_01U_00_01false_01_4.html">pointer_traits_rebind&lt; S&lt; T, Args... &gt;, U, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind specialization that reconstructs variadic pointer templates when <code>rebind&lt;U&gt;</code> is absent.  <a href="../../da/d50/structstd__ivy_1_1pointer__traits__rebind_3_01S_3_01T_00_01Args_8_8_8_01_4_00_01U_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df5/structstd__ivy_1_1pointer__traits__rebind_3_01S_3_01T_00_01Args_8_8_8_01_4_00_01U_00_01true_01_4.html">pointer_traits_rebind&lt; S&lt; T, Args... &gt;, U, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind specialization for variadic pointer templates when <code>rebind&lt;U&gt;</code> exists.  <a href="../../d5/df5/structstd__ivy_1_1pointer__traits__rebind_3_01S_3_01T_00_01Args_8_8_8_01_4_00_01U_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d48/structstd__ivy_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random-access-iterator category tag.  <a href="../../d2/d48/structstd__ivy_1_1random__access__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d0d/structstd__ivy_1_1stashing__iterator.html">stashing_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait detecting presence of stashing_iterator_tag marker.  <a href="../../de/d0d/structstd__ivy_1_1stashing__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddb/structstd__ivy_1_1stashing__iterator_3_01T_00_01std__ttraits_1_1void__t_3_01typename_01T_1_1stashing__iterator__tag_01_4_01_4.html">stashing_iterator&lt; T, std_ttraits::void_t&lt; typename T::stashing_iterator_tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive specialization of <a class="el" href="../../de/d0d/structstd__ivy_1_1stashing__iterator.html" title="Trait detecting presence of stashing_iterator_tag marker.">stashing_iterator</a> when marker tag exists.  <a href="../../dd/ddb/structstd__ivy_1_1stashing__iterator_3_01T_00_01std__ttraits_1_1void__t_3_01typename_01T_1_1stashing__iterator__tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d3a/classstd__ivy_1_1transfer__memory__primitive.html">transfer_memory_primitive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dde/classstd__ivy_1_1transfer__memory__primitive_3_01IvyBucketedIteratorBuilder_3_01Key_00_01T_00_01Hash_01_4_01_4.html">transfer_memory_primitive&lt; IvyBucketedIteratorBuilder&lt; Key, T, Hash &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d97/classstd__ivy_1_1transfer__memory__primitive_3_01IvyClientManager_3_01T_01_4_01_4.html">transfer_memory_primitive&lt; IvyClientManager&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d0a/classstd__ivy_1_1transfer__memory__primitive_3_01IvyComplexVariable_3_01T_01_4_01_4.html">transfer_memory_primitive&lt; IvyComplexVariable&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da0/classstd__ivy_1_1transfer__memory__primitive_3_01IvyConstant_3_01T_01_4_01_4.html">transfer_memory_primitive&lt; IvyConstant&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd9/classstd__ivy_1_1transfer__memory__primitive_3_01IvyContiguousIterator_3_01T_00_01ContiguousTag_01_4_01_4.html">transfer_memory_primitive&lt; IvyContiguousIterator&lt; T, ContiguousTag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d88/classstd__ivy_1_1transfer__memory__primitive_3_01IvyContiguousIteratorBuilder_3_01T_01_4_01_4.html">transfer_memory_primitive&lt; IvyContiguousIteratorBuilder&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d5a/classstd__ivy_1_1transfer__memory__primitive_3_01IvyTensor_3_01T_01_4_01_4.html">transfer_memory_primitive&lt; IvyTensor&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d62/classstd__ivy_1_1transfer__memory__primitive_3_01IvyUnifiedPtr_3_01T_00_01IPT_01_4_01_4.html">transfer_memory_primitive&lt; IvyUnifiedPtr&lt; T, IPT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer-memory primitive specialization for <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> types.  <a href="../../d3/d62/classstd__ivy_1_1transfer__memory__primitive_3_01IvyUnifiedPtr_3_01T_00_01IPT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db5/classstd__ivy_1_1transfer__memory__primitive_3_01IvyUnorderedMap_3_01Key_00_01T_00_01Hash_00_01K5ea11f2a3295bc2568c21c8fc8910e5e.html">transfer_memory_primitive&lt; IvyUnorderedMap&lt; Key, T, Hash, KeyEqual, HashEqual, Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer-memory primitive specialization for <a class="el" href="../../d0/d3c/classstd__ivy_1_1IvyUnorderedMap.html" title="Forward declaration of IvyUnorderedMap.">IvyUnorderedMap</a>.  <a href="../../d5/db5/classstd__ivy_1_1transfer__memory__primitive_3_01IvyUnorderedMap_3_01Key_00_01T_00_01Hash_00_01K5ea11f2a3295bc2568c21c8fc8910e5e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5f/classstd__ivy_1_1transfer__memory__primitive_3_01IvyVariable_3_01T_01_4_01_4.html">transfer_memory_primitive&lt; IvyVariable&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3c/classstd__ivy_1_1transfer__memory__primitive_3_01IvyVector_3_01T_00_01Allocator_01_4_01_4.html">transfer_memory_primitive&lt; IvyVector&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer-memory primitive specialization for <a class="el" href="../../d2/d97/classstd__ivy_1_1IvyVector.html" title="Forward declaration of IvyVector.">IvyVector</a>.  <a href="../../d5/d3c/classstd__ivy_1_1transfer__memory__primitive_3_01IvyVector_3_01T_00_01Allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1f/classstd__ivy_1_1transfer__memory__primitive_3_01std__util_1_1pair_3_01T_00_01U_01_4_01_4.html">transfer_memory_primitive&lt; std_util::pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d66/classstd__ivy_1_1transfer__memory__primitive__with__internal__memory.html">transfer_memory_primitive_with_internal_memory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d4a/classstd__ivy_1_1transfer__memory__primitive__with__internal__memory_3_01T_00_01ENABLE__IF__TYPEdc6d4e9acdc93de1ebfae73978297567.html">transfer_memory_primitive_with_internal_memory&lt; T, ENABLE_IF_TYPED_BASE_OF_IMPL(T, IvyClientManager&lt; T &gt;, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de4/classstd__ivy_1_1transfer__memory__primitive__without__internal__memory.html">transfer_memory_primitive_without_internal_memory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d9f/structstd__ivy_1_1value__printout.html">value_printout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary printout traits template; specialized per printable type.  <a href="../../d2/d9f/structstd__ivy_1_1value__printout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d63/structstd__ivy_1_1value__printout_3_01bool_01_4.html">value_printout&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print boolean values as textual true/false.  <a href="../../d2/d63/structstd__ivy_1_1value__printout_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dcb/structstd__ivy_1_1value__printout_3_01char_01_5_01_4.html">value_printout&lt; char * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print mutable C-string values.  <a href="../../d4/dcb/structstd__ivy_1_1value__printout_3_01char_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d19/structstd__ivy_1_1value__printout_3_01char_01const_01_5_01_4.html">value_printout&lt; char const * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print immutable C-string values.  <a href="../../df/d19/structstd__ivy_1_1value__printout_3_01char_01const_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d07/structstd__ivy_1_1value__printout_3_01double_01_4.html">value_printout&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print double in fixed-point format.  <a href="../../d8/d07/structstd__ivy_1_1value__printout_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de1/structstd__ivy_1_1value__printout_3_01float_01_4.html">value_printout&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print float in fixed-point format.  <a href="../../db/de1/structstd__ivy_1_1value__printout_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de3/structstd__ivy_1_1value__printout_3_01int_01_4.html">value_printout&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print int as signed integer.  <a href="../../d7/de3/structstd__ivy_1_1value__printout_3_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/ddc/structstd__ivy_1_1value__printout_3_01IvyMath_1_1IvyComplexVariable_3_01T_01_4_01_4.html">value_printout&lt; IvyMath::IvyComplexVariable&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d96/structstd__ivy_1_1value__printout_3_01IvyMath_1_1IvyConstant_3_01T_01_4_01_4.html">value_printout&lt; IvyMath::IvyConstant&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d27/structstd__ivy_1_1value__printout_3_01IvyMath_1_1IvyFunction_3_01Args_8_8_8_01_4_01_4.html">value_printout&lt; IvyMath::IvyFunction&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d57/structstd__ivy_1_1value__printout_3_01IvyMath_1_1IvyTensor_3_01T_01_4_01_4.html">value_printout&lt; IvyMath::IvyTensor&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d98/structstd__ivy_1_1value__printout_3_01IvyMath_1_1IvyVariable_3_01T_01_4_01_4.html">value_printout&lt; IvyMath::IvyVariable&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddb/structstd__ivy_1_1value__printout_3_01IvyUnifiedPtr_3_01T_00_01IPT_01_4_01_4.html">value_printout&lt; IvyUnifiedPtr&lt; T, IPT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d69/structstd__ivy_1_1value__printout_3_01IvyUnorderedMap_01____UMAPTPLARGS_____01_4.html">value_printout&lt; IvyUnorderedMap __UMAPTPLARGS__ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d02/structstd__ivy_1_1value__printout_3_01IvyVector_3_01T_00_01Allocator_01_4_01_4.html">value_printout&lt; IvyVector&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d93/structstd__ivy_1_1value__printout_3_01long_01double_01_4.html">value_printout&lt; long double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print long double in fixed-point format.  <a href="../../d1/d93/structstd__ivy_1_1value__printout_3_01long_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0e/structstd__ivy_1_1value__printout_3_01long_01int_01_4.html">value_printout&lt; long int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print long int as signed long integer.  <a href="../../df/d0e/structstd__ivy_1_1value__printout_3_01long_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3b/structstd__ivy_1_1value__printout_3_01long_01long_01int_01_4.html">value_printout&lt; long long int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print long long int as signed long long integer.  <a href="../../d8/d3b/structstd__ivy_1_1value__printout_3_01long_01long_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de7/structstd__ivy_1_1value__printout_3_01short_01_4.html">value_printout&lt; short &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print short as signed integer.  <a href="../../d4/de7/structstd__ivy_1_1value__printout_3_01short_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8d/structstd__ivy_1_1value__printout_3_01signed_01char_01_4.html">value_printout&lt; signed char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print signed char as character.  <a href="../../d6/d8d/structstd__ivy_1_1value__printout_3_01signed_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfe/structstd__ivy_1_1value__printout_3_01std__ilist_1_1initializer__list_3_01T_01_4_01_4.html">value_printout&lt; std_ilist::initializer_list&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print initializer_list as <code>{ elem0, elem1, ... }</code> or <code>(empty)</code>.  <a href="../../d3/dfe/structstd__ivy_1_1value__printout_3_01std__ilist_1_1initializer__list_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5a/structstd__ivy_1_1value__printout_3_01std__util_1_1pair_3_01T_00_01U_01_4_01_4.html">value_printout&lt; std_util::pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print std_util::pair as <code>(first, second)</code>.  <a href="../../d4/d5a/structstd__ivy_1_1value__printout_3_01std__util_1_1pair_3_01T_00_01U_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d0d/structstd__ivy_1_1value__printout_3_01T_01const_01_4.html">value_printout&lt; T const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward const-qualified printing to non-const <a class="el" href="../../d2/d9f/structstd__ivy_1_1value__printout.html" title="Primary printout traits template; specialized per printable type.">value_printout</a> specialization.  <a href="../../d5/d0d/structstd__ivy_1_1value__printout_3_01T_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d15/structstd__ivy_1_1value__printout_3_01unsigned_01char_01_4.html">value_printout&lt; unsigned char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print unsigned char as unsigned integer.  <a href="../../db/d15/structstd__ivy_1_1value__printout_3_01unsigned_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d2d/structstd__ivy_1_1value__printout_3_01unsigned_01int_01_4.html">value_printout&lt; unsigned int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print unsigned int as unsigned integer.  <a href="../../d8/d2d/structstd__ivy_1_1value__printout_3_01unsigned_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd7/structstd__ivy_1_1value__printout_3_01unsigned_01long_01int_01_4.html">value_printout&lt; unsigned long int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print unsigned long int as unsigned long integer.  <a href="../../d9/dd7/structstd__ivy_1_1value__printout_3_01unsigned_01long_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d78/structstd__ivy_1_1value__printout_3_01unsigned_01long_01long_01int_01_4.html">value_printout&lt; unsigned long long int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print unsigned long long int as unsigned long long integer.  <a href="../../d2/d78/structstd__ivy_1_1value__printout_3_01unsigned_01long_01long_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d9b/structstd__ivy_1_1value__printout_3_01unsigned_01short_01_4.html">value_printout&lt; unsigned short &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print unsigned short as unsigned integer.  <a href="../../d2/d9b/structstd__ivy_1_1value__printout_3_01unsigned_01short_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acf13c81346ddc447ebcd6fd5b256d9aa" id="r_acf13c81346ddc447ebcd6fd5b256d9aa"><td class="memItemLeft" align="right" valign="top"><a id="acf13c81346ddc447ebcd6fd5b256d9aa" name="acf13c81346ddc447ebcd6fd5b256d9aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IvyMemoryType</b> = <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryHelpers::IvyMemoryType</a></td></tr>
<tr class="separator:acf13c81346ddc447ebcd6fd5b256d9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace26af0ba8bffd734fa1be2216cf7c43" id="r_ace26af0ba8bffd734fa1be2216cf7c43"><td class="memTemplParams" colspan="2"><a id="ace26af0ba8bffd734fa1be2216cf7c43" name="ace26af0ba8bffd734fa1be2216cf7c43"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace26af0ba8bffd734fa1be2216cf7c43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hash</b> = <a class="el" href="../../df/d29/structivy__hash__impl_1_1IvyHash.html">ivy_hash_impl::IvyHash</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ace26af0ba8bffd734fa1be2216cf7c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public hash alias used throughout <a class="el" href="../../d1/da1/namespacestd__ivy.html">std_ivy</a> containers. <br /></td></tr>
<tr class="separator:ace26af0ba8bffd734fa1be2216cf7c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd10d40651f278e1f1c85443e92161b" id="r_a9fd10d40651f278e1f1c85443e92161b"><td class="memTemplParams" colspan="2"><a id="a9fd10d40651f278e1f1c85443e92161b" name="a9fd10d40651f278e1f1c85443e92161b"></a>
template&lt;typename T , typename ContiguousTag  = contiguous_iterator_tag&gt; </td></tr>
<tr class="memitem:a9fd10d40651f278e1f1c85443e92161b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IvyVectorConstIterator</b> = <a class="el" href="../../d3/db9/classstd__ivy_1_1IvyContiguousIterator.html">IvyContiguousIterator</a>&lt; T const, ContiguousTag &gt;</td></tr>
<tr class="separator:a9fd10d40651f278e1f1c85443e92161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b5881619954ca6e6f47552175972e1" id="r_aa2b5881619954ca6e6f47552175972e1"><td class="memItemLeft" align="right" valign="top"><a id="aa2b5881619954ca6e6f47552175972e1" name="aa2b5881619954ca6e6f47552175972e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stashing_iterator_tag</b> = void</td></tr>
<tr class="memdesc:aa2b5881619954ca6e6f47552175972e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker tag type for iterators that cannot be safely reversed. <br /></td></tr>
<tr class="separator:aa2b5881619954ca6e6f47552175972e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bbba5facc04b36d2c570ee1060e0fc" id="r_a66bbba5facc04b36d2c570ee1060e0fc"><td class="memTemplParams" colspan="2"><a id="a66bbba5facc04b36d2c570ee1060e0fc" name="a66bbba5facc04b36d2c570ee1060e0fc"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a66bbba5facc04b36d2c570ee1060e0fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pointer_traits_rebind_t</b> = typename <a class="el" href="../../d5/d90/structstd__ivy_1_1pointer__traits__rebind.html">pointer_traits_rebind</a>&lt; T, U &gt;::type</td></tr>
<tr class="memdesc:a66bbba5facc04b36d2c570ee1060e0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for the result type of <code><a class="el" href="../../d5/d90/structstd__ivy_1_1pointer__traits__rebind.html" title="Rebind resolver for pointer-like types that define rebind&lt;U&gt;.">pointer_traits_rebind</a></code>. <br /></td></tr>
<tr class="separator:a66bbba5facc04b36d2c570ee1060e0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01163061a0bd0caaf20d100b9e1cde0" id="r_af01163061a0bd0caaf20d100b9e1cde0"><td class="memTemplParams" colspan="2"><a id="af01163061a0bd0caaf20d100b9e1cde0" name="af01163061a0bd0caaf20d100b9e1cde0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af01163061a0bd0caaf20d100b9e1cde0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shared_ptr</b> = <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4ca9e81e7b963c71363e2fb3eefcfecfc0e">IvyPointerType::shared</a> &gt;</td></tr>
<tr class="memdesc:af01163061a0bd0caaf20d100b9e1cde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> alias. <br /></td></tr>
<tr class="separator:af01163061a0bd0caaf20d100b9e1cde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551a25ac8b1958933135d79e15980337" id="r_a551a25ac8b1958933135d79e15980337"><td class="memTemplParams" colspan="2"><a id="a551a25ac8b1958933135d79e15980337" name="a551a25ac8b1958933135d79e15980337"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a551a25ac8b1958933135d79e15980337"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique_ptr</b> = <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4ca673eb027e9c056f57140322807351dd5">IvyPointerType::unique</a> &gt;</td></tr>
<tr class="memdesc:a551a25ac8b1958933135d79e15980337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique-ownership <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> alias. <br /></td></tr>
<tr class="separator:a551a25ac8b1958933135d79e15980337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c729886f9722b54db32349343deab5" id="r_a52c729886f9722b54db32349343deab5"><td class="memTemplParams" colspan="2"><a id="a52c729886f9722b54db32349343deab5" name="a52c729886f9722b54db32349343deab5"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:a52c729886f9722b54db32349343deab5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unifiedptr_view</b> = <a class="el" href="../../d1/d86/classstd__ivy_1_1memview.html">std_ivy::memview</a>&lt; <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; &gt;</td></tr>
<tr class="memdesc:a52c729886f9722b54db32349343deab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-view alias over <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> objects. <br /></td></tr>
<tr class="separator:a52c729886f9722b54db32349343deab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9422cf7431c1704a251f36c7a6a1040a" id="r_a9422cf7431c1704a251f36c7a6a1040a"><td class="memTemplParams" colspan="2"><a id="a9422cf7431c1704a251f36c7a6a1040a" name="a9422cf7431c1704a251f36c7a6a1040a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9422cf7431c1704a251f36c7a6a1040a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sharedptr_view</b> = <a class="el" href="../../d1/da1/namespacestd__ivy.html#a52c729886f9722b54db32349343deab5">unifiedptr_view</a>&lt; T, <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4ca9e81e7b963c71363e2fb3eefcfecfc0e">IvyPointerType::shared</a> &gt;</td></tr>
<tr class="memdesc:a9422cf7431c1704a251f36c7a6a1040a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-view alias for shared_ptr. <br /></td></tr>
<tr class="separator:a9422cf7431c1704a251f36c7a6a1040a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197b0c413657afee917d2053e3281cf9" id="r_a197b0c413657afee917d2053e3281cf9"><td class="memTemplParams" colspan="2"><a id="a197b0c413657afee917d2053e3281cf9" name="a197b0c413657afee917d2053e3281cf9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a197b0c413657afee917d2053e3281cf9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>uniqueptr_view</b> = <a class="el" href="../../d1/da1/namespacestd__ivy.html#a52c729886f9722b54db32349343deab5">unifiedptr_view</a>&lt; T, <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4ca673eb027e9c056f57140322807351dd5">IvyPointerType::unique</a> &gt;</td></tr>
<tr class="memdesc:a197b0c413657afee917d2053e3281cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-view alias for unique_ptr. <br /></td></tr>
<tr class="separator:a197b0c413657afee917d2053e3281cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde39cd2cdd78196cf14554ab04a57e1" id="r_abde39cd2cdd78196cf14554ab04a57e1"><td class="memTemplParams" colspan="2"><a id="abde39cd2cdd78196cf14554ab04a57e1" name="abde39cd2cdd78196cf14554ab04a57e1"></a>
template&lt;typename Key , typename T , typename Hash  = std_ivy::hash&lt;Key const&gt;, typename KeyEqual  = std_ivy::IvyKeyEqualEvalDefault&lt;Key const&gt;, typename HashEqual  = std_ivy::IvyHashEqualEvalDefault&lt;typename Hash::result_type&gt;, typename Allocator  = std_mem::allocator&lt;std_util::pair&lt;Key const, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:abde39cd2cdd78196cf14554ab04a57e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unordered_map</b> = <a class="el" href="../../d0/d3c/classstd__ivy_1_1IvyUnorderedMap.html">IvyUnorderedMap</a>&lt; Key, T, Hash, KeyEqual, HashEqual, Allocator &gt;</td></tr>
<tr class="memdesc:abde39cd2cdd78196cf14554ab04a57e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style alias for <a class="el" href="../../d0/d3c/classstd__ivy_1_1IvyUnorderedMap.html" title="Forward declaration of IvyUnorderedMap.">IvyUnorderedMap</a>. <br /></td></tr>
<tr class="separator:abde39cd2cdd78196cf14554ab04a57e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132c4c37d7ae3aa25df9516c89bc04d4" id="r_a132c4c37d7ae3aa25df9516c89bc04d4"><td class="memTemplParams" colspan="2"><a id="a132c4c37d7ae3aa25df9516c89bc04d4" name="a132c4c37d7ae3aa25df9516c89bc04d4"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a132c4c37d7ae3aa25df9516c89bc04d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IvyKeyEqualEval</b> = <a class="el" href="../../d9/dc0/structstd__ivy_1_1IvyKeyEqualBinaryEval.html">IvyKeyEqualBinaryEval</a>&lt; Key, std_fcnal::equal_to&lt; Key &gt; &gt;</td></tr>
<tr class="memdesc:a132c4c37d7ae3aa25df9516c89bc04d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-equality evaluator using std_fcnal::equal_to. <br /></td></tr>
<tr class="separator:a132c4c37d7ae3aa25df9516c89bc04d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c31ee8fc1ca0c5f989b8b7c9e0f906b" id="r_a5c31ee8fc1ca0c5f989b8b7c9e0f906b"><td class="memTemplParams" colspan="2"><a id="a5c31ee8fc1ca0c5f989b8b7c9e0f906b" name="a5c31ee8fc1ca0c5f989b8b7c9e0f906b"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a5c31ee8fc1ca0c5f989b8b7c9e0f906b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IvyKeyEqualEvalDefault</b> = <a class="el" href="../../d1/da1/namespacestd__ivy.html#a132c4c37d7ae3aa25df9516c89bc04d4">IvyKeyEqualEval</a>&lt; Key &gt;</td></tr>
<tr class="memdesc:a5c31ee8fc1ca0c5f989b8b7c9e0f906b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default key-equality evaluator alias. <br /></td></tr>
<tr class="separator:a5c31ee8fc1ca0c5f989b8b7c9e0f906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf3cf17cac2c170fec00bf759c4d07" id="r_afbbf3cf17cac2c170fec00bf759c4d07"><td class="memTemplParams" colspan="2"><a id="afbbf3cf17cac2c170fec00bf759c4d07" name="afbbf3cf17cac2c170fec00bf759c4d07"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:afbbf3cf17cac2c170fec00bf759c4d07"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IvyHashEqualEvalDefault</b> = <a class="el" href="../../d3/d82/structstd__ivy_1_1IvyKeyEqualBySqrtNSizeEval.html">IvyKeyEqualBySqrtNSizeEval</a>&lt; Key &gt;</td></tr>
<tr class="memdesc:afbbf3cf17cac2c170fec00bf759c4d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default hash-equality evaluator alias. <br /></td></tr>
<tr class="separator:afbbf3cf17cac2c170fec00bf759c4d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e0f9f87bffba06aeb0c36f39940c2d" id="r_a20e0f9f87bffba06aeb0c36f39940c2d"><td class="memTemplParams" colspan="2"><a id="a20e0f9f87bffba06aeb0c36f39940c2d" name="a20e0f9f87bffba06aeb0c36f39940c2d"></a>
template&lt;typename T , typename Allocator  = std_mem::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a20e0f9f87bffba06aeb0c36f39940c2d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector</b> = <a class="el" href="../../d2/d97/classstd__ivy_1_1IvyVector.html">IvyVector</a>&lt; T, Allocator &gt;</td></tr>
<tr class="memdesc:a20e0f9f87bffba06aeb0c36f39940c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style alias for <a class="el" href="../../d2/d97/classstd__ivy_1_1IvyVector.html" title="Forward declaration of IvyVector.">IvyVector</a>. <br /></td></tr>
<tr class="separator:a20e0f9f87bffba06aeb0c36f39940c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3269bb1ce5daa3b9d08b063f6c0a6d4c" id="r_a3269bb1ce5daa3b9d08b063f6c0a6d4c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> { <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4ca9e81e7b963c71363e2fb3eefcfecfc0e">shared</a>
, <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4ca673eb027e9c056f57140322807351dd5">unique</a>
 }</td></tr>
<tr class="memdesc:a3269bb1ce5daa3b9d08b063f6c0a6d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ownership mode for IvyUnifiedPtr.  <a href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">More...</a><br /></td></tr>
<tr class="separator:a3269bb1ce5daa3b9d08b063f6c0a6d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac2e378bc677b4e428da00f55dccb5cdd" id="r_ac2e378bc677b4e428da00f55dccb5cdd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2e378bc677b4e428da00f55dccb5cdd"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#ac2e378bc677b4e428da00f55dccb5cdd">print_value</a> (T const &amp;var, bool put_endl=true)</td></tr>
<tr class="memdesc:ac2e378bc677b4e428da00f55dccb5cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a value using the corresponding <code><a class="el" href="../../d2/d9f/structstd__ivy_1_1value__printout.html" title="Primary printout traits template; specialized per printable type.">value_printout</a></code> specialization.  <br /></td></tr>
<tr class="separator:ac2e378bc677b4e428da00f55dccb5cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c68c445c480cbd1a3ed4861df8d142" id="r_a43c68c445c480cbd1a3ed4861df8d142"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:a43c68c445c480cbd1a3ed4861df8d142"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#a43c68c445c480cbd1a3ed4861df8d142">find</a> (Iterator first, Iterator last, T const &amp;v)</td></tr>
<tr class="memdesc:a43c68c445c480cbd1a3ed4861df8d142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first element equal to a target value.  <br /></td></tr>
<tr class="separator:a43c68c445c480cbd1a3ed4861df8d142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353c2ca211fe926e7533218f859c1b82" id="r_a353c2ca211fe926e7533218f859c1b82"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a353c2ca211fe926e7533218f859c1b82"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#a353c2ca211fe926e7533218f859c1b82">find_if</a> (Iterator first, Iterator last, UnaryPredicate p)</td></tr>
<tr class="memdesc:a353c2ca211fe926e7533218f859c1b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first element satisfying a unary predicate.  <br /></td></tr>
<tr class="separator:a353c2ca211fe926e7533218f859c1b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d00f317ecfb311b4aa8f51ccd959683" id="r_a7d00f317ecfb311b4aa8f51ccd959683"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a7d00f317ecfb311b4aa8f51ccd959683"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#a7d00f317ecfb311b4aa8f51ccd959683">find_if_not</a> (Iterator first, Iterator last, UnaryPredicate p)</td></tr>
<tr class="memdesc:a7d00f317ecfb311b4aa8f51ccd959683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first element that does not satisfy a unary predicate.  <br /></td></tr>
<tr class="separator:a7d00f317ecfb311b4aa8f51ccd959683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28909df03c27f80108904e184bfaba4c" id="r_a28909df03c27f80108904e184bfaba4c"><td class="memTemplParams" colspan="2"><a id="a28909df03c27f80108904e184bfaba4c" name="a28909df03c27f80108904e184bfaba4c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28909df03c27f80108904e184bfaba4c"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (T const &amp;x, T const &amp;y)</td></tr>
<tr class="memdesc:a28909df03c27f80108904e184bfaba4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smaller of two values using operator&gt;. <br /></td></tr>
<tr class="separator:a28909df03c27f80108904e184bfaba4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f559bbbe4834fdae00122f2b19a1c3" id="r_ab1f559bbbe4834fdae00122f2b19a1c3"><td class="memTemplParams" colspan="2"><a id="ab1f559bbbe4834fdae00122f2b19a1c3" name="ab1f559bbbe4834fdae00122f2b19a1c3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1f559bbbe4834fdae00122f2b19a1c3"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (T const &amp;x, T const &amp;y)</td></tr>
<tr class="memdesc:ab1f559bbbe4834fdae00122f2b19a1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the larger of two values using operator&gt;. <br /></td></tr>
<tr class="separator:ab1f559bbbe4834fdae00122f2b19a1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea91b2b03c1042d50cacc114078b530d" id="r_aea91b2b03c1042d50cacc114078b530d"><td class="memTemplParams" colspan="2"><a id="aea91b2b03c1042d50cacc114078b530d" name="aea91b2b03c1042d50cacc114078b530d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea91b2b03c1042d50cacc114078b530d"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (T const &amp;x, T const &amp;y, T &amp;__RESTRICT__ i, T &amp;__RESTRICT__ a)</td></tr>
<tr class="memdesc:aea91b2b03c1042d50cacc114078b530d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum and maximum into reference outputs. <br /></td></tr>
<tr class="separator:aea91b2b03c1042d50cacc114078b530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a9256d989e8cfdd498a3bc64ee6c63" id="r_af5a9256d989e8cfdd498a3bc64ee6c63"><td class="memTemplParams" colspan="2"><a id="af5a9256d989e8cfdd498a3bc64ee6c63" name="af5a9256d989e8cfdd498a3bc64ee6c63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5a9256d989e8cfdd498a3bc64ee6c63"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (T const &amp;x, T const &amp;y, T *__RESTRICT__ i, T *__RESTRICT__ a)</td></tr>
<tr class="memdesc:af5a9256d989e8cfdd498a3bc64ee6c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum and maximum addresses into pointer outputs. <br /></td></tr>
<tr class="separator:af5a9256d989e8cfdd498a3bc64ee6c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa777ea709ab61bf328191ad1b76cf64c" id="r_aa777ea709ab61bf328191ad1b76cf64c"><td class="memTemplParams" colspan="2"><a id="aa777ea709ab61bf328191ad1b76cf64c" name="aa777ea709ab61bf328191ad1b76cf64c"></a>
template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:aa777ea709ab61bf328191ad1b76cf64c"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (T const &amp;x, T const &amp;y, C comp, T &amp;__RESTRICT__ i, T &amp;__RESTRICT__ a)</td></tr>
<tr class="memdesc:aa777ea709ab61bf328191ad1b76cf64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum and maximum using a custom comparator into reference outputs. <br /></td></tr>
<tr class="separator:aa777ea709ab61bf328191ad1b76cf64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36e9deb739d5bed34b451f42287bbab" id="r_ab36e9deb739d5bed34b451f42287bbab"><td class="memTemplParams" colspan="2"><a id="ab36e9deb739d5bed34b451f42287bbab" name="ab36e9deb739d5bed34b451f42287bbab"></a>
template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:ab36e9deb739d5bed34b451f42287bbab"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (T const &amp;x, T const &amp;y, C comp, T *__RESTRICT__ i, T *__RESTRICT__ a)</td></tr>
<tr class="memdesc:ab36e9deb739d5bed34b451f42287bbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum and maximum using a custom comparator into pointer outputs. <br /></td></tr>
<tr class="separator:ab36e9deb739d5bed34b451f42287bbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6713cc8e5b9f4d5a6cb62ada2ca2e4f5" id="r_a6713cc8e5b9f4d5a6cb62ada2ca2e4f5"><td class="memTemplParams" colspan="2"><a id="a6713cc8e5b9f4d5a6cb62ada2ca2e4f5" name="a6713cc8e5b9f4d5a6cb62ada2ca2e4f5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6713cc8e5b9f4d5a6cb62ada2ca2e4f5"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ __CPP_CONSTEXPR__ std_util::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (T const &amp;x, T const &amp;y)</td></tr>
<tr class="memdesc:a6713cc8e5b9f4d5a6cb62ada2ca2e4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ordered pair of minimum and maximum values. <br /></td></tr>
<tr class="separator:a6713cc8e5b9f4d5a6cb62ada2ca2e4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd7155750691bdc3b3c524badeba071" id="r_addd7155750691bdc3b3c524badeba071"><td class="memTemplParams" colspan="2"><a id="addd7155750691bdc3b3c524badeba071" name="addd7155750691bdc3b3c524badeba071"></a>
template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:addd7155750691bdc3b3c524badeba071"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ __CPP_CONSTEXPR__ std_util::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (T const &amp;x, T const &amp;y, C comp)</td></tr>
<tr class="memdesc:addd7155750691bdc3b3c524badeba071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ordered pair of minimum and maximum values with a custom comparator. <br /></td></tr>
<tr class="separator:addd7155750691bdc3b3c524badeba071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33416c8f9492783edd18a5069828eae" id="r_ae33416c8f9492783edd18a5069828eae"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename C &gt; </td></tr>
<tr class="memitem:ae33416c8f9492783edd18a5069828eae"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ __CPP_CONSTEXPR__ std_util::pair&lt; ForwardIt, ForwardIt &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#ae33416c8f9492783edd18a5069828eae">minmax_element</a> (ForwardIt first, ForwardIt last, C comp)</td></tr>
<tr class="memdesc:ae33416c8f9492783edd18a5069828eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find iterators to the minimum and maximum elements in a range.  <br /></td></tr>
<tr class="separator:ae33416c8f9492783edd18a5069828eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe320210484ff4973c5d8c7923a54052" id="r_abe320210484ff4973c5d8c7923a54052"><td class="memTemplParams" colspan="2"><a id="abe320210484ff4973c5d8c7923a54052" name="abe320210484ff4973c5d8c7923a54052"></a>
template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:abe320210484ff4973c5d8c7923a54052"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ __CPP_CONSTEXPR__ std_util::pair&lt; ForwardIt, ForwardIt &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax_element</b> (ForwardIt first, ForwardIt last)</td></tr>
<tr class="memdesc:abe320210484ff4973c5d8c7923a54052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find iterators to minimum and maximum elements using default less-than ordering. <br /></td></tr>
<tr class="separator:abe320210484ff4973c5d8c7923a54052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0928d33e786722e861141a0974aa350d" id="r_a0928d33e786722e861141a0974aa350d"><td class="memTemplParams" colspan="2"><a id="a0928d33e786722e861141a0974aa350d" name="a0928d33e786722e861141a0974aa350d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0928d33e786722e861141a0974aa350d"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ __CPP_CONSTEXPR__ std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (std_ilist::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a0928d33e786722e861141a0974aa350d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum and maximum values from an initializer list. <br /></td></tr>
<tr class="separator:a0928d33e786722e861141a0974aa350d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29a9904d82089d367fe42b288821710" id="r_ad29a9904d82089d367fe42b288821710"><td class="memTemplParams" colspan="2"><a id="ad29a9904d82089d367fe42b288821710" name="ad29a9904d82089d367fe42b288821710"></a>
template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:ad29a9904d82089d367fe42b288821710"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ __CPP_CONSTEXPR__ std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minmax</b> (std_ilist::initializer_list&lt; T &gt; ilist, C comp)</td></tr>
<tr class="memdesc:ad29a9904d82089d367fe42b288821710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum and maximum values from an initializer list using a custom comparator. <br /></td></tr>
<tr class="separator:ad29a9904d82089d367fe42b288821710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974d6ba7a2e12c9f7c93d9af4ed27ed6" id="r_a974d6ba7a2e12c9f7c93d9af4ed27ed6"><td class="memTemplParams" colspan="2"><a id="a974d6ba7a2e12c9f7c93d9af4ed27ed6" name="a974d6ba7a2e12c9f7c93d9af4ed27ed6"></a>
template&lt;typename C , typename T &gt; </td></tr>
<tr class="memitem:a974d6ba7a2e12c9f7c93d9af4ed27ed6"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>op_parallel_core</b> (<a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n_serial, T *vals, IvyGPUStream &amp;stream, int dyn_shared_mem=0)</td></tr>
<tr class="memdesc:a974d6ba7a2e12c9f7c93d9af4ed27ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive core routine for parallel grouped operation execution. <br /></td></tr>
<tr class="separator:a974d6ba7a2e12c9f7c93d9af4ed27ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135bd121fe021dcb1307f92ad3cc5f3a" id="r_a135bd121fe021dcb1307f92ad3cc5f3a"><td class="memTemplParams" colspan="2"><a id="a135bd121fe021dcb1307f92ad3cc5f3a" name="a135bd121fe021dcb1307f92ad3cc5f3a"></a>
template&lt;typename C , typename T &gt; </td></tr>
<tr class="memitem:a135bd121fe021dcb1307f92ad3cc5f3a"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>op_parallel</b> (T *h_vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n_serial, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type_vals, IvyGPUStream &amp;stream, int dyn_shared_mem=0)</td></tr>
<tr class="memdesc:a135bd121fe021dcb1307f92ad3cc5f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a grouped parallel operation and return the final reduced value. <br /></td></tr>
<tr class="separator:a135bd121fe021dcb1307f92ad3cc5f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5b49ed97864fc4a5e545ac0b11e1d" id="r_aa3f5b49ed97864fc4a5e545ac0b11e1d"><td class="memTemplParams" colspan="2"><a id="aa3f5b49ed97864fc4a5e545ac0b11e1d" name="aa3f5b49ed97864fc4a5e545ac0b11e1d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3f5b49ed97864fc4a5e545ac0b11e1d"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_parallel</b> (T *h_vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n_serial, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type_vals, IvyGPUStream &amp;stream, int dyn_shared_mem=0)</td></tr>
<tr class="memdesc:aa3f5b49ed97864fc4a5e545ac0b11e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel addition entry point. <br /></td></tr>
<tr class="separator:aa3f5b49ed97864fc4a5e545ac0b11e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1ae1f9777801efc72539955bf02dcb" id="r_a8b1ae1f9777801efc72539955bf02dcb"><td class="memTemplParams" colspan="2"><a id="a8b1ae1f9777801efc72539955bf02dcb" name="a8b1ae1f9777801efc72539955bf02dcb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b1ae1f9777801efc72539955bf02dcb"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply_parallel</b> (T *h_vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n_serial, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type_vals, IvyGPUStream &amp;stream, int dyn_shared_mem=0)</td></tr>
<tr class="memdesc:a8b1ae1f9777801efc72539955bf02dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multiplication entry point. <br /></td></tr>
<tr class="separator:a8b1ae1f9777801efc72539955bf02dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a961820e6ea5caa37cf28f429e0417f" id="r_a5a961820e6ea5caa37cf28f429e0417f"><td class="memTemplParams" colspan="2"><a id="a5a961820e6ea5caa37cf28f429e0417f" name="a5a961820e6ea5caa37cf28f429e0417f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a961820e6ea5caa37cf28f429e0417f"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtract_parallel</b> (T *h_vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n_serial, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type_vals, IvyGPUStream &amp;stream, int dyn_shared_mem=0)</td></tr>
<tr class="memdesc:a5a961820e6ea5caa37cf28f429e0417f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel subtraction entry point. <br /></td></tr>
<tr class="separator:a5a961820e6ea5caa37cf28f429e0417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e1cf271c1f8bcd8422e1665b10d795" id="r_aa2e1cf271c1f8bcd8422e1665b10d795"><td class="memTemplParams" colspan="2"><a id="aa2e1cf271c1f8bcd8422e1665b10d795" name="aa2e1cf271c1f8bcd8422e1665b10d795"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2e1cf271c1f8bcd8422e1665b10d795"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divide_parallel</b> (T *h_vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n_serial, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type_vals, IvyGPUStream &amp;stream, int dyn_shared_mem=0)</td></tr>
<tr class="memdesc:aa2e1cf271c1f8bcd8422e1665b10d795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel division entry point. <br /></td></tr>
<tr class="separator:aa2e1cf271c1f8bcd8422e1665b10d795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2bafdf747ea98390be8e70e3ac2ca8" id="r_aab2bafdf747ea98390be8e70e3ac2ca8"><td class="memTemplParams" colspan="2"><a id="aab2bafdf747ea98390be8e70e3ac2ca8" name="aab2bafdf747ea98390be8e70e3ac2ca8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab2bafdf747ea98390be8e70e3ac2ca8"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_serial</b> (T *vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n)</td></tr>
<tr class="memdesc:aab2bafdf747ea98390be8e70e3ac2ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial addition helper. <br /></td></tr>
<tr class="separator:aab2bafdf747ea98390be8e70e3ac2ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d92436d93dbf5cf3ee4128440a88f3" id="r_ab8d92436d93dbf5cf3ee4128440a88f3"><td class="memTemplParams" colspan="2"><a id="ab8d92436d93dbf5cf3ee4128440a88f3" name="ab8d92436d93dbf5cf3ee4128440a88f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8d92436d93dbf5cf3ee4128440a88f3"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply_serial</b> (T *vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n)</td></tr>
<tr class="memdesc:ab8d92436d93dbf5cf3ee4128440a88f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial multiplication helper. <br /></td></tr>
<tr class="separator:ab8d92436d93dbf5cf3ee4128440a88f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357976cfe27d51c7bb5096397ecf63fc" id="r_a357976cfe27d51c7bb5096397ecf63fc"><td class="memTemplParams" colspan="2"><a id="a357976cfe27d51c7bb5096397ecf63fc" name="a357976cfe27d51c7bb5096397ecf63fc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a357976cfe27d51c7bb5096397ecf63fc"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtract_serial</b> (T *vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n)</td></tr>
<tr class="memdesc:a357976cfe27d51c7bb5096397ecf63fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial subtraction helper. <br /></td></tr>
<tr class="separator:a357976cfe27d51c7bb5096397ecf63fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3479bef075eb3639b1dd63aca486bb" id="r_a8b3479bef075eb3639b1dd63aca486bb"><td class="memTemplParams" colspan="2"><a id="a8b3479bef075eb3639b1dd63aca486bb" name="a8b3479bef075eb3639b1dd63aca486bb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b3479bef075eb3639b1dd63aca486bb"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divide_serial</b> (T *vals, <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">IvyTypes::size_t</a> n)</td></tr>
<tr class="memdesc:a8b3479bef075eb3639b1dd63aca486bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial division helper. <br /></td></tr>
<tr class="separator:a8b3479bef075eb3639b1dd63aca486bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f93c1c796e00547b27b0be9b3e32097" id="r_a3f93c1c796e00547b27b0be9b3e32097"><td class="memItemLeft" align="right" valign="top"><a id="a3f93c1c796e00547b27b0be9b3e32097" name="a3f93c1c796e00547b27b0be9b3e32097"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DEFINE_HAS_CALL</b> (data)</td></tr>
<tr class="separator:a3f93c1c796e00547b27b0be9b3e32097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087ba1a12d76935e78435c4531306580" id="r_a087ba1a12d76935e78435c4531306580"><td class="memItemLeft" align="right" valign="top"><a id="a087ba1a12d76935e78435c4531306580" name="a087ba1a12d76935e78435c4531306580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DEFINE_HAS_CALL</b> (<a class="el" href="../../d1/da1/namespacestd__ivy.html#a9aafe080cccdc76e5d119b2c65d7717b">begin</a>)</td></tr>
<tr class="separator:a087ba1a12d76935e78435c4531306580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2ca84cd36d448c6798dd5692a4225d" id="r_aaa2ca84cd36d448c6798dd5692a4225d"><td class="memTemplParams" colspan="2">template&lt;typename T , std_ttraits::enable_if_t&lt; has_call_data_v&lt; T &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:aaa2ca84cd36d448c6798dd5692a4225d"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#aaa2ca84cd36d448c6798dd5692a4225d">get_data_head</a> (T &amp;t)</td></tr>
<tr class="memdesc:aaa2ca84cd36d448c6798dd5692a4225d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data head using <code>data()</code> when available.  <br /></td></tr>
<tr class="separator:aaa2ca84cd36d448c6798dd5692a4225d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecf0c6a396933db8729e0b6a49fde87" id="r_a0ecf0c6a396933db8729e0b6a49fde87"><td class="memTemplParams" colspan="2"><a id="a0ecf0c6a396933db8729e0b6a49fde87" name="a0ecf0c6a396933db8729e0b6a49fde87"></a>
template&lt;typename T , typename D , typename P , typename R &gt; </td></tr>
<tr class="memitem:a0ecf0c6a396933db8729e0b6a49fde87"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;x, <a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;y)</td></tr>
<tr class="memdesc:a0ecf0c6a396933db8729e0b6a49fde87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between input iterators. <br /></td></tr>
<tr class="separator:a0ecf0c6a396933db8729e0b6a49fde87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb083daf13b483e21171a28632ab86" id="r_aa0eb083daf13b483e21171a28632ab86"><td class="memTemplParams" colspan="2"><a id="aa0eb083daf13b483e21171a28632ab86" name="aa0eb083daf13b483e21171a28632ab86"></a>
template&lt;typename T , typename D , typename P , typename R &gt; </td></tr>
<tr class="memitem:aa0eb083daf13b483e21171a28632ab86"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;x, <a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;y)</td></tr>
<tr class="memdesc:aa0eb083daf13b483e21171a28632ab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between input iterators. <br /></td></tr>
<tr class="separator:aa0eb083daf13b483e21171a28632ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94060798e10607c908e268c3579c847" id="r_af94060798e10607c908e268c3579c847"><td class="memTemplParams" colspan="2"><a id="af94060798e10607c908e268c3579c847" name="af94060798e10607c908e268c3579c847"></a>
template&lt;typename T , typename D , typename P , typename R &gt; </td></tr>
<tr class="memitem:af94060798e10607c908e268c3579c847"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;x, <a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;y)</td></tr>
<tr class="memdesc:af94060798e10607c908e268c3579c847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict-weak ordering comparison between input iterators. <br /></td></tr>
<tr class="separator:af94060798e10607c908e268c3579c847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55180b1a9313285bdc21c89ba64eb619" id="r_a55180b1a9313285bdc21c89ba64eb619"><td class="memTemplParams" colspan="2"><a id="a55180b1a9313285bdc21c89ba64eb619" name="a55180b1a9313285bdc21c89ba64eb619"></a>
template&lt;typename T , typename D , typename P , typename R &gt; </td></tr>
<tr class="memitem:a55180b1a9313285bdc21c89ba64eb619"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;x, <a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;y)</td></tr>
<tr class="memdesc:a55180b1a9313285bdc21c89ba64eb619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal comparison between input iterators. <br /></td></tr>
<tr class="separator:a55180b1a9313285bdc21c89ba64eb619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ce0ef4c5587e502d72e1bb6c4088d" id="r_a031ce0ef4c5587e502d72e1bb6c4088d"><td class="memTemplParams" colspan="2"><a id="a031ce0ef4c5587e502d72e1bb6c4088d" name="a031ce0ef4c5587e502d72e1bb6c4088d"></a>
template&lt;typename T , typename D , typename P , typename R &gt; </td></tr>
<tr class="memitem:a031ce0ef4c5587e502d72e1bb6c4088d"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;x, <a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;y)</td></tr>
<tr class="memdesc:a031ce0ef4c5587e502d72e1bb6c4088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between input iterators. <br /></td></tr>
<tr class="separator:a031ce0ef4c5587e502d72e1bb6c4088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7354f93d90b75f7e1fabf9985bdc0d6f" id="r_a7354f93d90b75f7e1fabf9985bdc0d6f"><td class="memTemplParams" colspan="2"><a id="a7354f93d90b75f7e1fabf9985bdc0d6f" name="a7354f93d90b75f7e1fabf9985bdc0d6f"></a>
template&lt;typename T , typename D , typename P , typename R &gt; </td></tr>
<tr class="memitem:a7354f93d90b75f7e1fabf9985bdc0d6f"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;x, <a class="el" href="../../d0/dc6/classstd__ivy_1_1IvyInputIterator.html">IvyInputIterator</a>&lt; T, D, P, R &gt; const &amp;y)</td></tr>
<tr class="memdesc:a7354f93d90b75f7e1fabf9985bdc0d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal comparison between input iterators. <br /></td></tr>
<tr class="separator:a7354f93d90b75f7e1fabf9985bdc0d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535f1f9863c04176d75a5bebd461a7ce" id="r_a535f1f9863c04176d75a5bebd461a7ce"><td class="memTemplParams" colspan="2"><a id="a535f1f9863c04176d75a5bebd461a7ce" name="a535f1f9863c04176d75a5bebd461a7ce"></a>
template&lt;typename It &gt; </td></tr>
<tr class="memitem:a535f1f9863c04176d75a5bebd461a7ce"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr <a class="el" href="../../db/d13/structstd__ivy_1_1iterator__traits.html">std_ivy::iterator_traits</a>&lt; It &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance</b> (It const &amp;first, It const &amp;last)</td></tr>
<tr class="memdesc:a535f1f9863c04176d75a5bebd461a7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two iterators. <br /></td></tr>
<tr class="separator:a535f1f9863c04176d75a5bebd461a7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aafe080cccdc76e5d119b2c65d7717b" id="r_a9aafe080cccdc76e5d119b2c65d7717b"><td class="memTemplParams" colspan="2"><a id="a9aafe080cccdc76e5d119b2c65d7717b" name="a9aafe080cccdc76e5d119b2c65d7717b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9aafe080cccdc76e5d119b2c65d7717b"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> (T &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:a9aafe080cccdc76e5d119b2c65d7717b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin iterator for mutable container. <br /></td></tr>
<tr class="separator:a9aafe080cccdc76e5d119b2c65d7717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d260f79f21a88157e38617830de5df0" id="r_a4d260f79f21a88157e38617830de5df0"><td class="memTemplParams" colspan="2"><a id="a4d260f79f21a88157e38617830de5df0" name="a4d260f79f21a88157e38617830de5df0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d260f79f21a88157e38617830de5df0"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> (T const &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:a4d260f79f21a88157e38617830de5df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin iterator for const container. <br /></td></tr>
<tr class="separator:a4d260f79f21a88157e38617830de5df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7536773a01af26ad423e9309d43c14d9" id="r_a7536773a01af26ad423e9309d43c14d9"><td class="memTemplParams" colspan="2"><a id="a7536773a01af26ad423e9309d43c14d9" name="a7536773a01af26ad423e9309d43c14d9"></a>
template&lt;typename T , <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7536773a01af26ad423e9309d43c14d9"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> (T(&amp;a)[N]) __NOEXCEPT__</td></tr>
<tr class="memdesc:a7536773a01af26ad423e9309d43c14d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin pointer for native array. <br /></td></tr>
<tr class="separator:a7536773a01af26ad423e9309d43c14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cab4a6dd38ea51b4876c2183ec28752" id="r_a5cab4a6dd38ea51b4876c2183ec28752"><td class="memTemplParams" colspan="2"><a id="a5cab4a6dd38ea51b4876c2183ec28752" name="a5cab4a6dd38ea51b4876c2183ec28752"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cab4a6dd38ea51b4876c2183ec28752"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cbegin</b> (T const &amp;c) -&gt; decltype(<a class="el" href="../../d1/da1/namespacestd__ivy.html#a9aafe080cccdc76e5d119b2c65d7717b">begin</a>(c))</td></tr>
<tr class="memdesc:a5cab4a6dd38ea51b4876c2183ec28752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const begin iterator. <br /></td></tr>
<tr class="separator:a5cab4a6dd38ea51b4876c2183ec28752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d1d3616ddd27402acc471f9ddb76f7" id="r_af6d1d3616ddd27402acc471f9ddb76f7"><td class="memTemplParams" colspan="2"><a id="af6d1d3616ddd27402acc471f9ddb76f7" name="af6d1d3616ddd27402acc471f9ddb76f7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6d1d3616ddd27402acc471f9ddb76f7"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> (T &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:af6d1d3616ddd27402acc471f9ddb76f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end iterator for mutable container. <br /></td></tr>
<tr class="separator:af6d1d3616ddd27402acc471f9ddb76f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634af6f72c7ef91e64288047f3c0b31b" id="r_a634af6f72c7ef91e64288047f3c0b31b"><td class="memTemplParams" colspan="2"><a id="a634af6f72c7ef91e64288047f3c0b31b" name="a634af6f72c7ef91e64288047f3c0b31b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a634af6f72c7ef91e64288047f3c0b31b"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> (T const &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:a634af6f72c7ef91e64288047f3c0b31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end iterator for const container. <br /></td></tr>
<tr class="separator:a634af6f72c7ef91e64288047f3c0b31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00554d04f7973ebad4c49c4f8ec3f615" id="r_a00554d04f7973ebad4c49c4f8ec3f615"><td class="memTemplParams" colspan="2"><a id="a00554d04f7973ebad4c49c4f8ec3f615" name="a00554d04f7973ebad4c49c4f8ec3f615"></a>
template&lt;typename T , <a class="el" href="../../d1/db3/IvyBasicTypes_8h.html#a4f444bfc2d9b446bd9e27c1d6f7f86f2">size_t</a> N&gt; </td></tr>
<tr class="memitem:a00554d04f7973ebad4c49c4f8ec3f615"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> (T(&amp;a)[N]) __NOEXCEPT__</td></tr>
<tr class="memdesc:a00554d04f7973ebad4c49c4f8ec3f615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end pointer for native array. <br /></td></tr>
<tr class="separator:a00554d04f7973ebad4c49c4f8ec3f615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66d94cee8213e2f3fea30b6e38917ce" id="r_ad66d94cee8213e2f3fea30b6e38917ce"><td class="memTemplParams" colspan="2"><a id="ad66d94cee8213e2f3fea30b6e38917ce" name="ad66d94cee8213e2f3fea30b6e38917ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad66d94cee8213e2f3fea30b6e38917ce"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cend</b> (T const &amp;c) -&gt; decltype(<a class="el" href="../../d1/da1/namespacestd__ivy.html#af6d1d3616ddd27402acc471f9ddb76f7">end</a>(c))</td></tr>
<tr class="memdesc:ad66d94cee8213e2f3fea30b6e38917ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const end iterator. <br /></td></tr>
<tr class="separator:ad66d94cee8213e2f3fea30b6e38917ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5c21f177231f1dd39b313b37bf3c6c" id="r_a0c5c21f177231f1dd39b313b37bf3c6c"><td class="memTemplParams" colspan="2"><a id="a0c5c21f177231f1dd39b313b37bf3c6c" name="a0c5c21f177231f1dd39b313b37bf3c6c"></a>
template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:a0c5c21f177231f1dd39b313b37bf3c6c"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;x, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;y)</td></tr>
<tr class="separator:a0c5c21f177231f1dd39b313b37bf3c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e60de5fa259c41a3ae3a76795f6528" id="r_a88e60de5fa259c41a3ae3a76795f6528"><td class="memTemplParams" colspan="2"><a id="a88e60de5fa259c41a3ae3a76795f6528" name="a88e60de5fa259c41a3ae3a76795f6528"></a>
template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:a88e60de5fa259c41a3ae3a76795f6528"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;x, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;y)</td></tr>
<tr class="separator:a88e60de5fa259c41a3ae3a76795f6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0549efb34fd2d518b3453627d5396c48" id="r_a0549efb34fd2d518b3453627d5396c48"><td class="memTemplParams" colspan="2"><a id="a0549efb34fd2d518b3453627d5396c48" name="a0549efb34fd2d518b3453627d5396c48"></a>
template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:a0549efb34fd2d518b3453627d5396c48"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;x, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;y)</td></tr>
<tr class="separator:a0549efb34fd2d518b3453627d5396c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475dbdbb05b19169694df0a7f2659874" id="r_a475dbdbb05b19169694df0a7f2659874"><td class="memTemplParams" colspan="2"><a id="a475dbdbb05b19169694df0a7f2659874" name="a475dbdbb05b19169694df0a7f2659874"></a>
template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:a475dbdbb05b19169694df0a7f2659874"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;x, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;y)</td></tr>
<tr class="separator:a475dbdbb05b19169694df0a7f2659874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70eb2e577be913e4db7eab9f2ca7154f" id="r_a70eb2e577be913e4db7eab9f2ca7154f"><td class="memTemplParams" colspan="2"><a id="a70eb2e577be913e4db7eab9f2ca7154f" name="a70eb2e577be913e4db7eab9f2ca7154f"></a>
template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:a70eb2e577be913e4db7eab9f2ca7154f"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;x, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;y)</td></tr>
<tr class="separator:a70eb2e577be913e4db7eab9f2ca7154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4641712027685d4d3647c625f43ad01" id="r_ad4641712027685d4d3647c625f43ad01"><td class="memTemplParams" colspan="2"><a id="ad4641712027685d4d3647c625f43ad01" name="ad4641712027685d4d3647c625f43ad01"></a>
template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:ad4641712027685d4d3647c625f43ad01"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;x, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;y)</td></tr>
<tr class="separator:ad4641712027685d4d3647c625f43ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045936c37b4e06b540cc3b8f5b7d17a2" id="r_a045936c37b4e06b540cc3b8f5b7d17a2"><td class="memTemplParams" colspan="2"><a id="a045936c37b4e06b540cc3b8f5b7d17a2" name="a045936c37b4e06b540cc3b8f5b7d17a2"></a>
template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:a045936c37b4e06b540cc3b8f5b7d17a2"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;x, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;y) -&gt; decltype(y.base() - x.base())</td></tr>
<tr class="separator:a045936c37b4e06b540cc3b8f5b7d17a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f8ddfa0a50ec8f12dd218c63c7048c" id="r_aa1f8ddfa0a50ec8f12dd218c63c7048c"><td class="memTemplParams" colspan="2"><a id="aa1f8ddfa0a50ec8f12dd218c63c7048c" name="aa1f8ddfa0a50ec8f12dd218c63c7048c"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aa1f8ddfa0a50ec8f12dd218c63c7048c"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (typename <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator &gt;::difference_type const &amp;n, <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator &gt; const &amp;it)</td></tr>
<tr class="separator:aa1f8ddfa0a50ec8f12dd218c63c7048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2bc2314b64b13575070882b52be241" id="r_a0e2bc2314b64b13575070882b52be241"><td class="memTemplParams" colspan="2"><a id="a0e2bc2314b64b13575070882b52be241" name="a0e2bc2314b64b13575070882b52be241"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a0e2bc2314b64b13575070882b52be241"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../db/d3e/classstd__ivy_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_reverse_iterator</b> (Iterator const &amp;it)</td></tr>
<tr class="separator:a0e2bc2314b64b13575070882b52be241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0956eebd3a54b94fb676d15ab13d00e" id="r_aa0956eebd3a54b94fb676d15ab13d00e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0956eebd3a54b94fb676d15ab13d00e"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ __CPP_CONSTEXPR__ T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#aa0956eebd3a54b94fb676d15ab13d00e">addressof</a> (T &amp;v) __NOEXCEPT__</td></tr>
<tr class="memdesc:aa0956eebd3a54b94fb676d15ab13d00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the true object address using compiler builtin support.  <br /></td></tr>
<tr class="separator:aa0956eebd3a54b94fb676d15ab13d00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3558f2b3861db9b610b816ffa2d338" id="r_aed3558f2b3861db9b610b816ffa2d338"><td class="memTemplParams" colspan="2"><a id="aed3558f2b3861db9b610b816ffa2d338" name="aed3558f2b3861db9b610b816ffa2d338"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed3558f2b3861db9b610b816ffa2d338"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addressof</b> (T const &amp;&amp;)=delete</td></tr>
<tr class="memdesc:aed3558f2b3861db9b610b816ffa2d338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted rvalue overload to prevent taking the address of temporaries. <br /></td></tr>
<tr class="separator:aed3558f2b3861db9b610b816ffa2d338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0ecf18207203f635015a16c6d99c7c" id="r_a5e0ecf18207203f635015a16c6d99c7c"><td class="memTemplParams" colspan="2"><a id="a5e0ecf18207203f635015a16c6d99c7c" name="a5e0ecf18207203f635015a16c6d99c7c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e0ecf18207203f635015a16c6d99c7c"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ T const *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addressof</b> (T const &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a5e0ecf18207203f635015a16c6d99c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted const-rvalue overload to prevent taking the address of temporaries. <br /></td></tr>
<tr class="separator:a5e0ecf18207203f635015a16c6d99c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06825d094d263f14718b95c31e067a45" id="r_a06825d094d263f14718b95c31e067a45"><td class="memTemplParams" colspan="2"><a id="a06825d094d263f14718b95c31e067a45" name="a06825d094d263f14718b95c31e067a45"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a06825d094d263f14718b95c31e067a45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d5/d3d/classstd__ivy_1_1allocator.html">std_ivy::allocator</a>&lt; T &gt; const &amp;, <a class="el" href="../../d5/d3d/classstd__ivy_1_1allocator.html">std_ivy::allocator</a>&lt; U &gt; const &amp;) noexcept</td></tr>
<tr class="memdesc:a06825d094d263f14718b95c31e067a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for allocator specializations. <br /></td></tr>
<tr class="separator:a06825d094d263f14718b95c31e067a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6626439416010e451ff4a6f477da8c" id="r_aeb6626439416010e451ff4a6f477da8c"><td class="memTemplParams" colspan="2"><a id="aeb6626439416010e451ff4a6f477da8c" name="aeb6626439416010e451ff4a6f477da8c"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aeb6626439416010e451ff4a6f477da8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d5/d3d/classstd__ivy_1_1allocator.html">std_ivy::allocator</a>&lt; T &gt; const &amp;a1, <a class="el" href="../../d5/d3d/classstd__ivy_1_1allocator.html">std_ivy::allocator</a>&lt; U &gt; const &amp;a2) noexcept</td></tr>
<tr class="memdesc:aeb6626439416010e451ff4a6f477da8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison for allocator specializations. <br /></td></tr>
<tr class="separator:aeb6626439416010e451ff4a6f477da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14c2924fbb1b3faaf13ed72f618d991" id="r_ad14c2924fbb1b3faaf13ed72f618d991"><td class="memTemplParams" colspan="2"><a id="ad14c2924fbb1b3faaf13ed72f618d991" name="ad14c2924fbb1b3faaf13ed72f618d991"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:ad14c2924fbb1b3faaf13ed72f618d991"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#a52c729886f9722b54db32349343deab5">unifiedptr_view</a>&lt; T, IPT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>view</b> (<a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;ptr)</td></tr>
<tr class="memdesc:ad14c2924fbb1b3faaf13ed72f618d991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memview over an <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> instance. <br /></td></tr>
<tr class="separator:ad14c2924fbb1b3faaf13ed72f618d991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a200a69daf8256f81402acf5354b6" id="r_ac70a200a69daf8256f81402acf5354b6"><td class="memTemplParams" colspan="2"><a id="ac70a200a69daf8256f81402acf5354b6" name="ac70a200a69daf8256f81402acf5354b6"></a>
template&lt;typename T , typename U , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPU&gt; </td></tr>
<tr class="memitem:ac70a200a69daf8256f81402acf5354b6"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a, <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; U, IPU &gt; const  &amp;b) __NOEXCEPT__</td></tr>
<tr class="memdesc:ac70a200a69daf8256f81402acf5354b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between compatible <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> instances. <br /></td></tr>
<tr class="separator:ac70a200a69daf8256f81402acf5354b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708e3de7cd3773a3a199fd62e4e22015" id="r_a708e3de7cd3773a3a199fd62e4e22015"><td class="memTemplParams" colspan="2"><a id="a708e3de7cd3773a3a199fd62e4e22015" name="a708e3de7cd3773a3a199fd62e4e22015"></a>
template&lt;typename T , typename U , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPU&gt; </td></tr>
<tr class="memitem:a708e3de7cd3773a3a199fd62e4e22015"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a, <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; U, IPU &gt; const  &amp;b) __NOEXCEPT__</td></tr>
<tr class="memdesc:a708e3de7cd3773a3a199fd62e4e22015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between compatible <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> instances. <br /></td></tr>
<tr class="separator:a708e3de7cd3773a3a199fd62e4e22015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d274a746f1db80ff27be16b4ea04a" id="r_af47d274a746f1db80ff27be16b4ea04a"><td class="memTemplParams" colspan="2"><a id="af47d274a746f1db80ff27be16b4ea04a" name="af47d274a746f1db80ff27be16b4ea04a"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:af47d274a746f1db80ff27be16b4ea04a"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a, T *ptr) __NOEXCEPT__</td></tr>
<tr class="memdesc:af47d274a746f1db80ff27be16b4ea04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> and raw pointer. <br /></td></tr>
<tr class="separator:af47d274a746f1db80ff27be16b4ea04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab982b46901f52931f14bd21bf71e4231" id="r_ab982b46901f52931f14bd21bf71e4231"><td class="memTemplParams" colspan="2"><a id="ab982b46901f52931f14bd21bf71e4231" name="ab982b46901f52931f14bd21bf71e4231"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:ab982b46901f52931f14bd21bf71e4231"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a, T *ptr) __NOEXCEPT__</td></tr>
<tr class="memdesc:ab982b46901f52931f14bd21bf71e4231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> and raw pointer. <br /></td></tr>
<tr class="separator:ab982b46901f52931f14bd21bf71e4231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed5ffbe9fecfc12fa33a36047b382c3" id="r_aaed5ffbe9fecfc12fa33a36047b382c3"><td class="memTemplParams" colspan="2"><a id="aaed5ffbe9fecfc12fa33a36047b382c3" name="aaed5ffbe9fecfc12fa33a36047b382c3"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:aaed5ffbe9fecfc12fa33a36047b382c3"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (T *ptr, <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a) __NOEXCEPT__</td></tr>
<tr class="memdesc:aaed5ffbe9fecfc12fa33a36047b382c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between raw pointer and <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a>. <br /></td></tr>
<tr class="separator:aaed5ffbe9fecfc12fa33a36047b382c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f450fb9ff5eecf8793033a25391689" id="r_ae7f450fb9ff5eecf8793033a25391689"><td class="memTemplParams" colspan="2"><a id="ae7f450fb9ff5eecf8793033a25391689" name="ae7f450fb9ff5eecf8793033a25391689"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:ae7f450fb9ff5eecf8793033a25391689"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (T *ptr, <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a) __NOEXCEPT__</td></tr>
<tr class="memdesc:ae7f450fb9ff5eecf8793033a25391689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between raw pointer and <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a>. <br /></td></tr>
<tr class="separator:ae7f450fb9ff5eecf8793033a25391689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0fa560a346491458791c3aae6c389c" id="r_a4a0fa560a346491458791c3aae6c389c"><td class="memTemplParams" colspan="2"><a id="a4a0fa560a346491458791c3aae6c389c" name="a4a0fa560a346491458791c3aae6c389c"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:a4a0fa560a346491458791c3aae6c389c"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a, std_cstddef::nullptr_t) __NOEXCEPT__</td></tr>
<tr class="memdesc:a4a0fa560a346491458791c3aae6c389c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> and nullptr. <br /></td></tr>
<tr class="separator:a4a0fa560a346491458791c3aae6c389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efb5469332fc3561152907bd14d3d76" id="r_a3efb5469332fc3561152907bd14d3d76"><td class="memTemplParams" colspan="2"><a id="a3efb5469332fc3561152907bd14d3d76" name="a3efb5469332fc3561152907bd14d3d76"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:a3efb5469332fc3561152907bd14d3d76"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a, std_cstddef::nullptr_t) __NOEXCEPT__</td></tr>
<tr class="memdesc:a3efb5469332fc3561152907bd14d3d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> and nullptr. <br /></td></tr>
<tr class="separator:a3efb5469332fc3561152907bd14d3d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c89e9cb704c0cbd530c4bd2433a408" id="r_a26c89e9cb704c0cbd530c4bd2433a408"><td class="memTemplParams" colspan="2"><a id="a26c89e9cb704c0cbd530c4bd2433a408" name="a26c89e9cb704c0cbd530c4bd2433a408"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:a26c89e9cb704c0cbd530c4bd2433a408"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std_cstddef::nullptr_t, <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a) __NOEXCEPT__</td></tr>
<tr class="memdesc:a26c89e9cb704c0cbd530c4bd2433a408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between nullptr and <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a>. <br /></td></tr>
<tr class="separator:a26c89e9cb704c0cbd530c4bd2433a408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08eb57ff25656adb17828b96bb2e6ed" id="r_ad08eb57ff25656adb17828b96bb2e6ed"><td class="memTemplParams" colspan="2"><a id="ad08eb57ff25656adb17828b96bb2e6ed" name="ad08eb57ff25656adb17828b96bb2e6ed"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT&gt; </td></tr>
<tr class="memitem:ad08eb57ff25656adb17828b96bb2e6ed"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std_cstddef::nullptr_t, <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt; const  &amp;a) __NOEXCEPT__</td></tr>
<tr class="memdesc:ad08eb57ff25656adb17828b96bb2e6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between nullptr and <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a>. <br /></td></tr>
<tr class="separator:ad08eb57ff25656adb17828b96bb2e6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fcb69241945f5495830d8d9eb74b10" id="r_a79fcb69241945f5495830d8d9eb74b10"><td class="memTemplParams" colspan="2"><a id="a79fcb69241945f5495830d8d9eb74b10" name="a79fcb69241945f5495830d8d9eb74b10"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:a79fcb69241945f5495830d8d9eb74b10"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_unified</b> (Allocator_t const  &amp;a, typename <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;::size_type n_size, typename <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;::size_type n_capacity, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a79fcb69241945f5495830d8d9eb74b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> with explicit allocator and size/capacity. <br /></td></tr>
<tr class="separator:a79fcb69241945f5495830d8d9eb74b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27b9f3fdfddf5902617dc8742a19309" id="r_aa27b9f3fdfddf5902617dc8742a19309"><td class="memTemplParams" colspan="2"><a id="aa27b9f3fdfddf5902617dc8742a19309" name="aa27b9f3fdfddf5902617dc8742a19309"></a>
template&lt;typename T , typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:aa27b9f3fdfddf5902617dc8742a19309"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_shared</b> (Allocator_t const  &amp;a, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;::size_type n_size, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;::size_type n_capacity, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa27b9f3fdfddf5902617dc8742a19309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build shared_ptr with explicit allocator and size/capacity. <br /></td></tr>
<tr class="separator:aa27b9f3fdfddf5902617dc8742a19309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922bccbc7a827ff873ff2ce481d80be3" id="r_a922bccbc7a827ff873ff2ce481d80be3"><td class="memTemplParams" colspan="2"><a id="a922bccbc7a827ff873ff2ce481d80be3" name="a922bccbc7a827ff873ff2ce481d80be3"></a>
template&lt;typename T , typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:a922bccbc7a827ff873ff2ce481d80be3"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_unique</b> (Allocator_t const  &amp;a, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;::size_type n_size, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;::size_type n_capacity, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a922bccbc7a827ff873ff2ce481d80be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build unique_ptr with explicit allocator and size/capacity. <br /></td></tr>
<tr class="separator:a922bccbc7a827ff873ff2ce481d80be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e284992ae450ca06060074cebcb476" id="r_ab8e284992ae450ca06060074cebcb476"><td class="memTemplParams" colspan="2"><a id="ab8e284992ae450ca06060074cebcb476" name="ab8e284992ae450ca06060074cebcb476"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, typename... Args&gt; </td></tr>
<tr class="memitem:ab8e284992ae450ca06060074cebcb476"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unified</b> (typename <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;::size_type n_size, typename <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;::size_type n_capacity, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab8e284992ae450ca06060074cebcb476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> with default allocator and size/capacity. <br /></td></tr>
<tr class="separator:ab8e284992ae450ca06060074cebcb476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277be4563f9e6b8477dea00f299f295b" id="r_a277be4563f9e6b8477dea00f299f295b"><td class="memTemplParams" colspan="2"><a id="a277be4563f9e6b8477dea00f299f295b" name="a277be4563f9e6b8477dea00f299f295b"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a277be4563f9e6b8477dea00f299f295b"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;::size_type n_size, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;::size_type n_capacity, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a277be4563f9e6b8477dea00f299f295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make shared_ptr with default allocator and size/capacity. <br /></td></tr>
<tr class="separator:a277be4563f9e6b8477dea00f299f295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243e72e3503d7783af2068b8af190fcc" id="r_a243e72e3503d7783af2068b8af190fcc"><td class="memTemplParams" colspan="2"><a id="a243e72e3503d7783af2068b8af190fcc" name="a243e72e3503d7783af2068b8af190fcc"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a243e72e3503d7783af2068b8af190fcc"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;::size_type n_size, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;::size_type n_capacity, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a243e72e3503d7783af2068b8af190fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make unique_ptr with default allocator and size/capacity. <br /></td></tr>
<tr class="separator:a243e72e3503d7783af2068b8af190fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e38fe656ba1ef3d883ec5ff560a33a" id="r_a04e38fe656ba1ef3d883ec5ff560a33a"><td class="memTemplParams" colspan="2"><a id="a04e38fe656ba1ef3d883ec5ff560a33a" name="a04e38fe656ba1ef3d883ec5ff560a33a"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:a04e38fe656ba1ef3d883ec5ff560a33a"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_unified</b> (Allocator_t const  &amp;a, typename <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;::size_type n, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a04e38fe656ba1ef3d883ec5ff560a33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> with explicit allocator and size only. <br /></td></tr>
<tr class="separator:a04e38fe656ba1ef3d883ec5ff560a33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0cbca956d176a4c8fc9c76d7d96462" id="r_aba0cbca956d176a4c8fc9c76d7d96462"><td class="memTemplParams" colspan="2"><a id="aba0cbca956d176a4c8fc9c76d7d96462" name="aba0cbca956d176a4c8fc9c76d7d96462"></a>
template&lt;typename T , typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:aba0cbca956d176a4c8fc9c76d7d96462"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_shared</b> (Allocator_t const  &amp;a, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;::size_type n, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aba0cbca956d176a4c8fc9c76d7d96462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build shared_ptr with explicit allocator and size only. <br /></td></tr>
<tr class="separator:aba0cbca956d176a4c8fc9c76d7d96462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6511fb6c74e5191d48504f51decb3f77" id="r_a6511fb6c74e5191d48504f51decb3f77"><td class="memTemplParams" colspan="2"><a id="a6511fb6c74e5191d48504f51decb3f77" name="a6511fb6c74e5191d48504f51decb3f77"></a>
template&lt;typename T , typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:a6511fb6c74e5191d48504f51decb3f77"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_unique</b> (Allocator_t const  &amp;a, typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;::size_type n, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6511fb6c74e5191d48504f51decb3f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build unique_ptr with explicit allocator and size only. <br /></td></tr>
<tr class="separator:a6511fb6c74e5191d48504f51decb3f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a3ff647fda20beedb301d41a0a1287" id="r_ac1a3ff647fda20beedb301d41a0a1287"><td class="memTemplParams" colspan="2"><a id="ac1a3ff647fda20beedb301d41a0a1287" name="ac1a3ff647fda20beedb301d41a0a1287"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, typename... Args&gt; </td></tr>
<tr class="memitem:ac1a3ff647fda20beedb301d41a0a1287"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unified</b> (typename <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;::size_type n, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac1a3ff647fda20beedb301d41a0a1287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> with default allocator and size only. <br /></td></tr>
<tr class="separator:ac1a3ff647fda20beedb301d41a0a1287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff39955101c74c2528ed5550a5aef820" id="r_aff39955101c74c2528ed5550a5aef820"><td class="memTemplParams" colspan="2"><a id="aff39955101c74c2528ed5550a5aef820" name="aff39955101c74c2528ed5550a5aef820"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aff39955101c74c2528ed5550a5aef820"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;::size_type n, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aff39955101c74c2528ed5550a5aef820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make shared_ptr with default allocator and size only. <br /></td></tr>
<tr class="separator:aff39955101c74c2528ed5550a5aef820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ff72a0ea46822cf3024e58ce48a559" id="r_a52ff72a0ea46822cf3024e58ce48a559"><td class="memTemplParams" colspan="2"><a id="a52ff72a0ea46822cf3024e58ce48a559" name="a52ff72a0ea46822cf3024e58ce48a559"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a52ff72a0ea46822cf3024e58ce48a559"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (typename <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;::size_type n, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a52ff72a0ea46822cf3024e58ce48a559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make unique_ptr with default allocator and size only. <br /></td></tr>
<tr class="separator:a52ff72a0ea46822cf3024e58ce48a559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccc14ed1f3325469102b757bea12db6" id="r_a8ccc14ed1f3325469102b757bea12db6"><td class="memTemplParams" colspan="2"><a id="a8ccc14ed1f3325469102b757bea12db6" name="a8ccc14ed1f3325469102b757bea12db6"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:a8ccc14ed1f3325469102b757bea12db6"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_unified</b> (Allocator_t const  &amp;a, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8ccc14ed1f3325469102b757bea12db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> with explicit allocator and default size semantics. <br /></td></tr>
<tr class="separator:a8ccc14ed1f3325469102b757bea12db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a7de69c59697754a31dfbc35644935" id="r_a58a7de69c59697754a31dfbc35644935"><td class="memTemplParams" colspan="2"><a id="a58a7de69c59697754a31dfbc35644935" name="a58a7de69c59697754a31dfbc35644935"></a>
template&lt;typename T , typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:a58a7de69c59697754a31dfbc35644935"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_shared</b> (Allocator_t const  &amp;a, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a58a7de69c59697754a31dfbc35644935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build shared_ptr with explicit allocator and default size semantics. <br /></td></tr>
<tr class="separator:a58a7de69c59697754a31dfbc35644935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d48e9b52e94297f09cb707d86b17dba" id="r_a9d48e9b52e94297f09cb707d86b17dba"><td class="memTemplParams" colspan="2"><a id="a9d48e9b52e94297f09cb707d86b17dba" name="a9d48e9b52e94297f09cb707d86b17dba"></a>
template&lt;typename T , typename Allocator_t , typename... Args&gt; </td></tr>
<tr class="memitem:a9d48e9b52e94297f09cb707d86b17dba"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_unique</b> (Allocator_t const  &amp;a, <a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9d48e9b52e94297f09cb707d86b17dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build unique_ptr with explicit allocator and default size semantics. <br /></td></tr>
<tr class="separator:a9d48e9b52e94297f09cb707d86b17dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cb1999cb4fb8b7c21b88110f59b7c2" id="r_aa3cb1999cb4fb8b7c21b88110f59b7c2"><td class="memTemplParams" colspan="2"><a id="aa3cb1999cb4fb8b7c21b88110f59b7c2" name="aa3cb1999cb4fb8b7c21b88110f59b7c2"></a>
template&lt;typename T , <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">IvyPointerType</a> IPT, typename... Args&gt; </td></tr>
<tr class="memitem:aa3cb1999cb4fb8b7c21b88110f59b7c2"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html">IvyUnifiedPtr</a>&lt; T, IPT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unified</b> (<a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa3cb1999cb4fb8b7c21b88110f59b7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a> with default allocator and default size semantics. <br /></td></tr>
<tr class="separator:aa3cb1999cb4fb8b7c21b88110f59b7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e04a25a65700ee05a86917e1e670b23" id="r_a7e04a25a65700ee05a86917e1e670b23"><td class="memTemplParams" colspan="2"><a id="a7e04a25a65700ee05a86917e1e670b23" name="a7e04a25a65700ee05a86917e1e670b23"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a7e04a25a65700ee05a86917e1e670b23"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#af01163061a0bd0caaf20d100b9e1cde0">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (<a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7e04a25a65700ee05a86917e1e670b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make shared_ptr with default allocator and default size semantics. <br /></td></tr>
<tr class="separator:a7e04a25a65700ee05a86917e1e670b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f97895b8df2f390c28db49745d981cb" id="r_a5f97895b8df2f390c28db49745d981cb"><td class="memTemplParams" colspan="2"><a id="a5f97895b8df2f390c28db49745d981cb" name="a5f97895b8df2f390c28db49745d981cb"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a5f97895b8df2f390c28db49745d981cb"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ <a class="el" href="../../d1/da1/namespacestd__ivy.html#a551a25ac8b1958933135d79e15980337">unique_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (<a class="el" href="../../d2/d12/namespaceIvyMemoryHelpers.html#a968c35d9f245459d30fd909562fa38a9">IvyMemoryType</a> mem_type, IvyGPUStream *stream, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5f97895b8df2f390c28db49745d981cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make unique_ptr with default allocator and default size semantics. <br /></td></tr>
<tr class="separator:a5f97895b8df2f390c28db49745d981cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d13caec63f41f0b841818a83b559a43" id="r_a8d13caec63f41f0b841818a83b559a43"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:a8d13caec63f41f0b841818a83b559a43"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#a8d13caec63f41f0b841818a83b559a43">accumulate</a> (Iterator first, Iterator last, T init)</td></tr>
<tr class="memdesc:a8d13caec63f41f0b841818a83b559a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold a range with addition starting from an initial value.  <br /></td></tr>
<tr class="separator:a8d13caec63f41f0b841818a83b559a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de1bb4fd4226016f3ecefe95b4df70e" id="r_a0de1bb4fd4226016f3ecefe95b4df70e"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a0de1bb4fd4226016f3ecefe95b4df70e"><td class="memTemplItemLeft" align="right" valign="top">__HOST_DEVICE__ constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da1/namespacestd__ivy.html#a0de1bb4fd4226016f3ecefe95b4df70e">accumulate</a> (Iterator first, Iterator last, T init, BinaryOperation op)</td></tr>
<tr class="memdesc:a0de1bb4fd4226016f3ecefe95b4df70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold a range with a custom binary operation starting from an initial value.  <br /></td></tr>
<tr class="separator:a0de1bb4fd4226016f3ecefe95b4df70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab0380c36aa3e935717398d0aecdb70dd" id="r_ab0380c36aa3e935717398d0aecdb70dd"><td class="memTemplParams" colspan="2"><a id="ab0380c36aa3e935717398d0aecdb70dd" name="ab0380c36aa3e935717398d0aecdb70dd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0380c36aa3e935717398d0aecdb70dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stashing_iterator_v</b> = <a class="el" href="../../de/d0d/structstd__ivy_1_1stashing__iterator.html">stashing_iterator</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ab0380c36aa3e935717398d0aecdb70dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience boolean for <a class="el" href="../../de/d0d/structstd__ivy_1_1stashing__iterator.html" title="Trait detecting presence of stashing_iterator_tag marker.">stashing_iterator</a> trait. <br /></td></tr>
<tr class="separator:ab0380c36aa3e935717398d0aecdb70dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f43b9448bc5ce300bc5c28710de41c" id="r_a38f43b9448bc5ce300bc5c28710de41c"><td class="memTemplParams" colspan="2"><a id="a38f43b9448bc5ce300bc5c28710de41c" name="a38f43b9448bc5ce300bc5c28710de41c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38f43b9448bc5ce300bc5c28710de41c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_contiguous_iterator_v</b> = <a class="el" href="../../dd/d07/structstd__ivy_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a38f43b9448bc5ce300bc5c28710de41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience boolean for contiguous-iterator trait. <br /></td></tr>
<tr class="separator:a38f43b9448bc5ce300bc5c28710de41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f40c255f60dd633838b24721784a1" id="r_a469f40c255f60dd633838b24721784a1"><td class="memItemLeft" align="right" valign="top"><a id="a469f40c255f60dd633838b24721784a1" name="a469f40c255f60dd633838b24721784a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__OBJC_POINTER_CMDS__</b></td></tr>
<tr class="separator:a469f40c255f60dd633838b24721784a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3a2f65e75d0a6b5661b251e3271a9a" id="r_a2e3a2f65e75d0a6b5661b251e3271a9a"><td class="memItemLeft" align="right" valign="top"><a id="a2e3a2f65e75d0a6b5661b251e3271a9a" name="a2e3a2f65e75d0a6b5661b251e3271a9a"></a>
constexpr <a class="el" href="../../d1/df9/structstd__ivy_1_1allocator__arg__t.html">allocator_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_arg</b></td></tr>
<tr class="memdesc:a2e3a2f65e75d0a6b5661b251e3271a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global tag instance for allocator-aware construction. <br /></td></tr>
<tr class="separator:a2e3a2f65e75d0a6b5661b251e3271a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75040426a12d33c4e18c5a9a9b34c3fd" id="r_a75040426a12d33c4e18c5a9a9b34c3fd"><td class="memItemLeft" align="right" valign="top"><a id="a75040426a12d33c4e18c5a9a9b34c3fd" name="a75040426a12d33c4e18c5a9a9b34c3fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>POINTER_TRAIT_CMDS</b></td></tr>
<tr class="separator:a75040426a12d33c4e18c5a9a9b34c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ab2afc5dbd5a626c472a974bf7d69e" id="r_a01ab2afc5dbd5a626c472a974bf7d69e"><td class="memTemplParams" colspan="2"><a id="a01ab2afc5dbd5a626c472a974bf7d69e" name="a01ab2afc5dbd5a626c472a974bf7d69e"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a01ab2afc5dbd5a626c472a974bf7d69e"><td class="memTemplItemLeft" align="right" valign="top">__INLINE_FCN_RELAXED__ constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_rebind_v</b> = <a class="el" href="../../d5/d3f/structstd__ivy_1_1has__rebind.html">has_rebind</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:a01ab2afc5dbd5a626c472a974bf7d69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience variable template for <code><a class="el" href="../../d5/d3f/structstd__ivy_1_1has__rebind.html" title="Detect whether a pointer-like type exposes a rebind&lt;U&gt; alias template.">has_rebind</a>&lt;T, U&gt;::value</code>. <br /></td></tr>
<tr class="separator:a01ab2afc5dbd5a626c472a974bf7d69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for parallel operations on arrays.</p>
<p>The main function is op_parallel. The arguments are as follows:</p><ul>
<li>h_vals: Pointer to the input array of values</li>
<li>n: Number of values</li>
<li>n_serial: Number of elements to group into a serial operation</li>
<li>mem_type_vals: Memory location of h_vals</li>
<li>stream: GPU stream for the parallelization</li>
<li>dyn_shared_mem: Amount of dynamic memory shared between threads of a GPU block</li>
</ul>
<p>The template arguments for op_parallel are as follows:</p><ul>
<li>C: Class with a static function op, which takes as arguments:<ul>
<li>res: Reference to the result of the operation</li>
<li>vals: Pointer to the arrays of values for a single parallel operation</li>
<li>n_serial: Number of elements to serialize within a single parallel operation</li>
</ul>
</li>
<li>T: Type of the values</li>
</ul>
<p>The following parallel operations are defined:</p><ul>
<li>add_parallel: Parallel addition</li>
<li>multiply_parallel: Parallel multiplication</li>
<li>subtract_parallel: Parallel subtraction</li>
<li>divide_parallel: Parallel division Equivalent operations *_serial serial over the host thread, i.e., a CPU or GPU thread, are also defined.</li>
</ul>
<p><a class="el" href="../../da/d9d/IvyUnorderedMapKeyEval_8h.html" title="Key extraction and equality/hash evaluation helpers for unordered_map nodes.">IvyUnorderedMapKeyEval.h</a>: A set of structs are provided to evaluate the equality of two keys for the <a class="el" href="../../d0/d3c/classstd__ivy_1_1IvyUnorderedMap.html" title="Forward declaration of IvyUnorderedMap.">IvyUnorderedMap</a>. The structs generalize the KeyEval concept of std::unordered_map to also receive the total present data size and capacity before insertion. In this way, information relevant to the stored data can be used in a more optimal manner than simply relying on key equality algorithms. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3269bb1ce5daa3b9d08b063f6c0a6d4c" name="a3269bb1ce5daa3b9d08b063f6c0a6d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3269bb1ce5daa3b9d08b063f6c0a6d4c">&#9670;&#160;</a></span>IvyPointerType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../d1/da1/namespacestd__ivy.html#a3269bb1ce5daa3b9d08b063f6c0a6d4c">std_ivy::IvyPointerType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ownership mode for <a class="el" href="../../df/d8d/classstd__ivy_1_1IvyUnifiedPtr.html" title="Forward declaration of the unified smart pointer template.">IvyUnifiedPtr</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3269bb1ce5daa3b9d08b063f6c0a6d4ca9e81e7b963c71363e2fb3eefcfecfc0e" name="a3269bb1ce5daa3b9d08b063f6c0a6d4ca9e81e7b963c71363e2fb3eefcfecfc0e"></a>shared&#160;</td><td class="fielddoc"><p>Shared ownership with reference counting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3269bb1ce5daa3b9d08b063f6c0a6d4ca673eb027e9c056f57140322807351dd5" name="a3269bb1ce5daa3b9d08b063f6c0a6d4ca673eb027e9c056f57140322807351dd5"></a>unique&#160;</td><td class="fielddoc"><p>Unique ownership with write-access transfer semantics. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8d13caec63f41f0b841818a83b559a43" name="a8d13caec63f41f0b841818a83b559a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d13caec63f41f0b841818a83b559a43">&#9670;&#160;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ constexpr T std_ivy::accumulate </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold a range with addition starting from an initial value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>Input iterator type. </td></tr>
    <tr><td class="paramname">T</td><td>Accumulator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range. </td></tr>
    <tr><td class="paramname">init</td><td>Initial accumulator value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final accumulated value. </dd></dl>

</div>
</div>
<a id="a0de1bb4fd4226016f3ecefe95b4df70e" name="a0de1bb4fd4226016f3ecefe95b4df70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de1bb4fd4226016f3ecefe95b4df70e">&#9670;&#160;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ constexpr T std_ivy::accumulate </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold a range with a custom binary operation starting from an initial value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>Input iterator type. </td></tr>
    <tr><td class="paramname">T</td><td>Accumulator type. </td></tr>
    <tr><td class="paramname">BinaryOperation</td><td>Binary operation type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range. </td></tr>
    <tr><td class="paramname">init</td><td>Initial accumulator value. </td></tr>
    <tr><td class="paramname">op</td><td>Binary operation applied at each step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final accumulated value. </dd></dl>

</div>
</div>
<a id="aa0956eebd3a54b94fb676d15ab13d00e" name="aa0956eebd3a54b94fb676d15ab13d00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0956eebd3a54b94fb676d15ab13d00e">&#9670;&#160;</a></span>addressof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__INLINE_FCN_RELAXED__ __HOST_DEVICE__ __CPP_CONSTEXPR__ T * std_ivy::addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the true object address using compiler builtin support. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Object reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to <code>v</code>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/da1/namespacestd__ivy_aa0956eebd3a54b94fb676d15ab13d00e_icgraph.png" border="0" usemap="#ad1/da1/namespacestd__ivy_aa0956eebd3a54b94fb676d15ab13d00e_icgraph" alt=""/></div>
<map name="ad1/da1/namespacestd__ivy_aa0956eebd3a54b94fb676d15ab13d00e_icgraph" id="ad1/da1/namespacestd__ivy_aa0956eebd3a54b94fb676d15ab13d00e_icgraph">
<area shape="rect" title="Obtain the true object address using compiler builtin support." alt="" coords="267,181,407,206"/>
<area shape="rect" href="../../da/d8b/classstd__ivy_1_1allocation__type__properties.html#a72b7691df436d6c5fe9ccec2f8de9708" title="Get the address of a const reference." alt="" coords="17,5,207,45"/>
<area shape="poly" title=" " alt="" coords="318,170,277,114,249,85,217,60,195,48,197,43,220,55,253,81,281,111,323,167"/>
<area shape="rect" href="../../da/d8b/classstd__ivy_1_1allocation__type__properties.html#a6e188302a5a60b390cf421866bb4cad8" title="Get the address of a mutable reference." alt="" coords="17,69,207,109"/>
<area shape="poly" title=" " alt="" coords="306,175,265,149,218,124,187,112,189,107,220,119,267,144,308,171"/>
<area shape="rect" href="../../d9/d43/classstd__ivy_1_1allocation__type__properties_3_01T_01const_01_4.html#ab1b12d8d58f7452b85a6d5dc16559d46" title="Get the address of a const reference." alt="" coords="35,134,189,189"/>
<area shape="poly" title=" " alt="" coords="253,184,189,175,190,170,253,179"/>
<area shape="rect" href="../../d1/d86/classstd__ivy_1_1memview.html#ae770eccd7247e395ae4b876ae129bc7e" title="Construct a single&#45;element view from a reference source." alt="" coords="5,213,219,238"/>
<area shape="poly" title=" " alt="" coords="253,208,202,215,201,210,253,203"/>
<area shape="rect" href="../../d0/d24/classstd__ivy_1_1pointer__traits_3_01T_01_5_01_4.html#ad10da1026f1a1e75b8aa65a9535f7004" title="Return the address of x as a raw pointer." alt="" coords="31,263,193,303"/>
<area shape="poly" title=" " alt="" coords="300,215,220,252,183,265,181,260,218,247,298,210"/>
<area shape="rect" href="../../d1/da1/namespacestd__ivy.html#ad14c2924fbb1b3faaf13ed72f618d991" title="Create a memview over an IvyUnifiedPtr instance." alt="" coords="59,327,165,353"/>
<area shape="poly" title=" " alt="" coords="321,219,279,269,251,295,220,317,193,329,166,336,165,331,192,324,217,312,248,291,275,265,317,216"/>
</map>
</div>

</div>
</div>
<a id="a43c68c445c480cbd1a3ed4861df8d142" name="a43c68c445c480cbd1a3ed4861df8d142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c68c445c480cbd1a3ed4861df8d142">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ constexpr Iterator std_ivy::find </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element equal to a target value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>Iterator type that supports dereference and increment. </td></tr>
    <tr><td class="paramname">T</td><td>Comparable value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>End of the input range. </td></tr>
    <tr><td class="paramname">v</td><td>Target value to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first matching element or <code>last</code> if not found. </dd></dl>

</div>
</div>
<a id="a353c2ca211fe926e7533218f859c1b82" name="a353c2ca211fe926e7533218f859c1b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353c2ca211fe926e7533218f859c1b82">&#9670;&#160;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ constexpr Iterator std_ivy::find_if </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element satisfying a unary predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>Iterator type that supports dereference and increment. </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>Predicate invocable with dereferenced iterator values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>End of the input range. </td></tr>
    <tr><td class="paramname">p</td><td>Predicate used for matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first matching element or <code>last</code> if not found. </dd></dl>

</div>
</div>
<a id="a7d00f317ecfb311b4aa8f51ccd959683" name="a7d00f317ecfb311b4aa8f51ccd959683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d00f317ecfb311b4aa8f51ccd959683">&#9670;&#160;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ constexpr Iterator std_ivy::find_if_not </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element that does not satisfy a unary predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>Iterator type that supports dereference and increment. </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>Predicate invocable with dereferenced iterator values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>End of the input range. </td></tr>
    <tr><td class="paramname">p</td><td>Predicate used for filtering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first non-matching element or <code>last</code> if not found. </dd></dl>

</div>
</div>
<a id="aaa2ca84cd36d448c6798dd5692a4225d" name="aaa2ca84cd36d448c6798dd5692a4225d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2ca84cd36d448c6798dd5692a4225d">&#9670;&#160;</a></span>get_data_head()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std_ttraits::enable_if_t&lt; has_call_data_v&lt; T &gt;, bool &gt;  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ auto std_ivy::get_data_head </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the data head using <code>data()</code> when available. </p>
<p>Return the object itself when neither <code>data()</code> nor <code><a class="el" href="../../d1/da1/namespacestd__ivy.html#a9aafe080cccdc76e5d119b2c65d7717b" title="Return begin iterator for mutable container.">begin()</a></code> is available.</p>
<p>Return the data head using <code><a class="el" href="../../d1/da1/namespacestd__ivy.html#a9aafe080cccdc76e5d119b2c65d7717b" title="Return begin iterator for mutable container.">begin()</a></code> when <code>data()</code> is unavailable. </p>

</div>
</div>
<a id="ae33416c8f9492783edd18a5069828eae" name="ae33416c8f9492783edd18a5069828eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33416c8f9492783edd18a5069828eae">&#9670;&#160;</a></span>minmax_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ __CPP_CONSTEXPR__ std_util::pair&lt; ForwardIt, ForwardIt &gt; std_ivy::minmax_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find iterators to the minimum and maximum elements in a range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIt</td><td>Forward iterator type. </td></tr>
    <tr><td class="paramname">C</td><td>Comparator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator returning true when first argument is ordered before second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators to minimum and maximum elements. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_cgraph.png" border="0" usemap="#ad1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_cgraph" alt=""/></div>
<map name="ad1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_cgraph" id="ad1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_cgraph">
<area shape="rect" title="Find iterators to the minimum and maximum elements in a range." alt="" coords="5,31,196,56"/>
<area shape="rect" href="../../d1/da1/namespacestd__ivy.html#ab1f559bbbe4834fdae00122f2b19a1c3" title="Return the larger of two values using operator&gt;." alt="" coords="244,5,349,31"/>
<area shape="poly" title=" " alt="" coords="196,28,230,24,231,29,197,34"/>
<area shape="rect" href="../../d1/da1/namespacestd__ivy.html#a28909df03c27f80108904e184bfaba4c" title="Return the smaller of two values using operator&gt;." alt="" coords="246,55,347,80"/>
<area shape="poly" title=" " alt="" coords="197,52,232,57,232,62,196,58"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_icgraph.png" border="0" usemap="#ad1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_icgraph" alt=""/></div>
<map name="ad1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_icgraph" id="ad1/da1/namespacestd__ivy_ae33416c8f9492783edd18a5069828eae_icgraph">
<area shape="rect" title="Find iterators to the minimum and maximum elements in a range." alt="" coords="244,55,435,80"/>
<area shape="rect" href="../../d1/da1/namespacestd__ivy.html#a0928d33e786722e861141a0974aa350d" title="Compute minimum and maximum values from an initializer list." alt="" coords="35,5,166,31"/>
<area shape="poly" title=" " alt="" coords="264,54,162,33,164,28,265,49"/>
<area shape="rect" href="../../d1/da1/namespacestd__ivy.html#ad29a9904d82089d367fe42b288821710" title="Compute minimum and maximum values from an initializer list using a custom comparator." alt="" coords="35,55,166,80"/>
<area shape="poly" title=" " alt="" coords="230,70,166,70,166,65,230,65"/>
<area shape="rect" href="../../d1/da1/namespacestd__ivy.html#abe320210484ff4973c5d8c7923a54052" title="Find iterators to minimum and maximum elements using default less&#45;than ordering." alt="" coords="5,104,196,129"/>
<area shape="poly" title=" " alt="" coords="265,85,164,107,162,101,264,80"/>
</map>
</div>

</div>
</div>
<a id="ac2e378bc677b4e428da00f55dccb5cdd" name="ac2e378bc677b4e428da00f55dccb5cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e378bc677b4e428da00f55dccb5cdd">&#9670;&#160;</a></span>print_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__HOST_DEVICE__ void std_ivy::print_value </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>put_endl</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a value using the corresponding <code><a class="el" href="../../d2/d9f/structstd__ivy_1_1value__printout.html" title="Primary printout traits template; specialized per printable type.">value_printout</a></code> specialization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Value to print. </td></tr>
    <tr><td class="paramname">put_endl</td><td>Append newline if true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
